ReferenceBean#getObject返回的ref为
ref = {proxy0@4260} 
 handler = {InvokerInvocationHandler@4280} 
  invoker = {ServiceDiscoveryMigrationInvoker@4263} 
  consumerModel = {ConsumerModel@4281} 
  url = {URL@4282} "dubbo://30.25.58.158/samples.servicediscovery.demo.DemoService?application=demo-consumer&check=false&dubbo=2.0.2&init=false&interface=samples.servicediscovery.demo.DemoService&mapping-type=metadata&mapping.type=metadata&metadata-type=remote&methods=sayHello&pid=64096&provided-by=demo-provider&register.ip=30.25.58.158&side=consumer&sticky=false&timestamp=1620702737234"
  protocolServiceKey = "samples.servicediscovery.demo.DemoService:dubbo"


  
// ====================================================================
// ====================================================================

客户端发起rpc的正向流程

// ====================================================================
// ====================================================================


String hello = demoService.sayHello("world");

InvokerInvocationHandler invoke

	method.getDeclaringClass() == Object.class
		return method.invoke(invoker, args);

	toString、hashCode、$destroy、equals

	RpcInvocation rpcInvocation = new RpcInvocation(method, invoker.getInterface().getName(), protocolServiceKey, args);
		this.methodName = methodName;
        this.serviceName = serviceName;
        this.protocolServiceKey = protocolServiceKey;
        this.parameterTypes = parameterTypes == null ? new Class<?>[0] : parameterTypes;
        this.arguments = arguments == null ? new Object[0] : arguments;
        this.attachments = attachments == null ? new HashMap<>() : attachments;
        this.attributes = attributes == null ? new HashMap<>() : attributes;
        this.invoker = invoker;
        initParameterDesc();
	
	rpcInvocation.setTargetServiceUniqueName(invoker.getUrl().getServiceKey());
		invoker.getUrl
			MigrationInvoker getUrl
				if (invoker != null) {
        				invoker.getUrl();
        					MockClusterInvoker getUrl
        						directory.getConsumerUrl()
        							RegistryDirectory.getConsumerUrl
        								overrideDirectoryUrl;
        									// dubbo://192.168.1.5/samples.annotation.api.HelloService?application=samples-annotation-consumer&dubbo=2.0.2&init=false&interface=samples.annotation.api.HelloService&metadata-type=remote&methods=sayHello,sayGoodbye&pid=41612&register.ip=192.168.1.5&revision=1.0.0_annotation&side=consumer&sticky=false&timeout=9999999&timestamp=1621747931579&version=1.0.0_annotation

	RpcContext.setRpcContext(invoker.getUrl());

		RpcContext.getContext().setConsumerUrl(url);

	if (consumerModel != null) {
        rpcInvocation.put(Constants.CONSUMER_MODEL, consumerModel);
        rpcInvocation.put(Constants.METHOD_MODEL, consumerModel.getMethodModel(method));
    }
       
	invoker.invoke(rpcInvocation).recreate();

		if (!checkInvokerAvailable(serviceDiscoveryInvoker)) {

			return serviceDiscoveryInvoker.invoke(invocation);

				MockClusterInvoker invoke

				.... // 同下

		if (!checkInvokerAvailable(invoker)) 
				return invoker != null && !invoker.isDestroyed() && invoker.isAvailable();
					
					MockClusterInvoker 	isDestroyed 
						return directory.isDestroyed();// directory 为 ServiceDiscoveryRegistryDirectory
							ServiceDiscoveryRegistryDirectory isDestroyed
								AbstractDirectory isDestroyed
									return destroyed;
					
					MockClusterInvoker 	isAvailable 
						return directory.isAvailable();	// directory 为 ServiceDiscoveryRegistryDirectory
							ServiceDiscoveryRegistryDirectory isAvailable
								if (isDestroyed()) {
						            return false;
						        }
						        Map<String, Invoker<T>> localUrlInvokerMap = urlInvokerMap; // 为null
						        if (localUrlInvokerMap != null && localUrlInvokerMap.size() > 0) {
						            for (Invoker<T> invoker : new ArrayList<>(localUrlInvokerMap.values())) {
						                if (invoker.isAvailable()) {
						                    return true;
						                }
						            }
						        }
						        return false; // 返回false
						   

			return invoker.invoke(invocation); // invoker为MockClusterInvoker

				MockClusterInvoker invoke

					String value = getUrl().getMethodParameter(invocation.getMethodName(), MOCK_KEY, Boolean.FALSE.toString()).trim();
			        if (value.length() == 0 || "false".equalsIgnoreCase(value)) {
			            result = this.invoker.invoke(invocation);
			            // 另换行
			        }

					AbstractCluster$InterceptorInvokerNode invoke

						ConsumerContextClusterInterceptor before
							context.setInvocation(invocation).setLocalAddress(NetUtils.getLocalHost(), 0);
							((RpcInvocation) invocation).setInvoker(invoker);
							RpcContext.removeServerContext();
								SERVER_LOCAL.remove(); // consumer端的，还有一个after是清除LOCAL

						ConsumerContextClusterInterceptor intercept 

							ClusterInterceptor intercept // 接口的默认方法
							
								clusterInvoker.invoke(invocation);
								
									AbstractClusterInvoker invoke  // this为 FailoverClusterInvoker

										checkWhetherDestroyed();
											if (destroyed.get()) 
            									throw new RpcException

										invocation.addObjectAttachments(RpcContext.getContext().getObjectAttachments());

										AbstractClusterInvoker list

											directory.list(invocation);

												AbstractDirectory list // this 为 RegistryDirectory

													if (destroyed) 
														throw

													doList(invocation);

														// registry://
														RegistryDirectory doList

															if (forbidden) {
															if (multiGroup) {

															return invokers = routerChain.route(getConsumerUrl(), invocation);
																RegistryDirectory getConsumerUrl()
																	return this.overrideDirectoryUrl;

																RouterChain route
																	 0 = {MockInvokersSelector@4654} 
																	 1 = {TagRouter@4655} 
																	 2 = {ServiceRouter@4656} 
																	 3 = {AppRouter@4657} 
														
														// sd://
														DynamicDirectory doList
															RouterChain route(mock、tag、service、app)
										initLoadBalance
											getExtension(invokers.get(0).getUrl().getMethodParameter("loadbalance","random"))

										RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);
											if (isAttachInvocationId(url, inv) && getInvocationId(inv) == null && inv instanceof RpcInvocation) {
									            inv.setAttachment(ID_KEY, String.valueOf(INVOKE_ID.getAndIncrement()));
									        }

									        isAttachInvocationId
									        	String value = url.getMethodParameter(invocation.getMethodName(), AUTO_ATTACH_INVOCATIONID_KEY);
										        if (value == null) {
										            // add invocationid in async operation by default
										            return isAsync(url, invocation);
										            	public static boolean isAsync(URL url, Invocation inv) {
												        boolean isAsync;

												        if (inv instanceof RpcInvocation) {
												            RpcInvocation rpcInvocation = (RpcInvocation) inv;
												            if (rpcInvocation.getInvokeMode() != null) {
												                return rpcInvocation.getInvokeMode() == InvokeMode.ASYNC;
												            }
												        }

												        if (Boolean.TRUE.toString().equals(inv.getAttachment(ASYNC_KEY))) {
												            isAsync = true;
												        } else {
												            isAsync = url.getMethodParameter(getMethodName(inv), ASYNC_KEY, false);
												        }
												        return isAsync;
												    }
										        } else if (Boolean.TRUE.toString().equalsIgnoreCase(value)) {
										            return true;
										        } else {
										            return false;
										        }

									        getInvocationId
									        	String id = inv.getAttachment(ID_KEY);
        										return id == null ? null : new Long(id);

										doInvoke(invocation, invokers, loadbalance);

											FailoverClusterInvoker doInvoke(Invocation invocation, final List<Invoker<T>> invokers, LoadBalance loadbalance)

												List<Invoker<T>> copyInvokers = invokers;

											 	checkInvokers(copyInvokers, invocation);
											 		if (CollectionUtils.isEmpty(invokers))
            											throw new RpcException(
            									
            									RpcException le = null; // last exception.
										        
										        List<Invoker<T>> invoked = new ArrayList<Invoker<T>>(copyInvokers.size());

										        Set<String> providers = new HashSet<String>(len);		
											 	
											 	int len = getUrl().getMethodParameter(methodName, RETRIES_KEY, DEFAULT_RETRIES) + 1; // 3
											 	for (int i = 0; i < len; i++)

											 		if (i > 0) {
											            checkWhetherDestroyed();
											            copyInvokers = list(invocation);
											            // check again
											            checkInvokers(copyInvokers, invocation);
											        }

											 		Invoker<T> invoker = select(loadbalance, invocation, copyInvokers, invoked);

											 		 	AbstractClusterInvoker select

											 		 		// sticky相关
											 		 		// ....
											 		 		doSelect(loadbalance, invocation, invokers, selected);

											 		 			if (invokers.size() == 1) {
														            return invokers.get(0);
														        }

											 		
													invoked.add(invoker);
														        
											 		RpcContext.getContext().setInvokers((List) invoked);

											 		Result result = invoker.invoke(invocation);

											 			RegistryDirectory$InvokerDelegate invoke
											 				InvokerWrapper invoke // InvokerWrapper 是 InvokerDelegate父类
											 					return invoker.invoke(invocation); // invoker为FilterNode
												 					FilterNode invoke 
												 						filter.invoke(next, invocation); // ConsumerContextFilter
												 							ConsumerContextFilter invoke
																				invoker.invoke(invocation);
																					FilterNode invoke 
																						filter.invoke(next, invocation);
																							FutureFilter invoke
																								MonitorFilter invoke
																									层次太深，另起开头

												finally {
									                providers.add(invoker.getUrl().getAddress());
									            }

ConsumerContextFilter invoke
	RpcContext context = RpcContext.getContext();
    context.setInvoker(invoker)
            .setInvocation(invocation)
            .setLocalAddress(NetUtils.getLocalHost(), 0)
            .setRemoteAddress(invoker.getUrl().getHost(), invoker.getUrl().getPort())
            .setRemoteApplicationName(invoker.getUrl().getParameter(REMOTE_APPLICATION_KEY))
            .setAttachment(REMOTE_APPLICATION_KEY, invoker.getUrl().getParameter(APPLICATION_KEY));
    if (invocation instanceof RpcInvocation) {
        ((RpcInvocation) invocation).setInvoker(invoker);
    }

    // pass default timeout set by end user (ReferenceConfig)
    Object countDown = context.get(TIME_COUNTDOWN_KEY);
    if (countDown != null) {
        TimeoutCountDown timeoutCountDown = (TimeoutCountDown) countDown;
        if (timeoutCountDown.isExpired()) {
            return AsyncRpcResult.newDefaultAsyncResult(new RpcException(RpcException.TIMEOUT_TERMINATE,
                    "No time left for making the following call: " + invocation.getServiceName() + "."
                            + invocation.getMethodName() + ", terminate directly."), invocation);
        }
    }
    return invoker.invoke(invocation);

FutureFilter
	fireInvokeCallback(invoker, invocation);
    return invoker.invoke(invocation);

MonitorFilter invoke
	if (invoker.getUrl().hasParameter(MONITOR_KEY)) {
        invocation.put(MONITOR_FILTER_START_TIME, System.currentTimeMillis());
        invocation.put(MONITOR_REMOTE_HOST_STORE, RpcContext.getContext().getRemoteHost());
        getConcurrent(invoker, invocation).incrementAndGet(); // count up
        	String key = invoker.getInterface().getName() + "." + invocation.getMethodName();
        	return concurrents.computeIfAbsent(key, k -> new AtomicInteger());
    }
    return invoker.invoke(invocation);

// 额外补充 CacheFilter，只有含有cache="lru"这种类似的参数才有效，在<dubbo:reference cache="lru">

CacheFilter invoke
if (cacheFactory != null && ConfigUtils.isNotEmpty(invoker.getUrl().getMethodParameter(invocation.getMethodName(), CACHE_KEY))) {
    Cache cache = cacheFactory.getCache(invoker.getUrl(), invocation);
    if (cache != null) {
        String key = StringUtils.toArgumentString(invocation.getArguments());
        Object value = cache.get(key);
        if (value != null) {
            if (value instanceof ValueWrapper) {
                return AsyncRpcResult.newDefaultAsyncResult(((ValueWrapper) value).get(), invocation);
            } else {
                return AsyncRpcResult.newDefaultAsyncResult(value, invocation);
            }
        }
        Result result = invoker.invoke(invocation);
        if (!result.hasException()) {
            cache.put(key, new ValueWrapper(result.getValue()));
        }
        return result;
    }
}
return invoker.invoke(invocation);

ListenerInvokerWrapper invoke

	AsyncToSyncInvoker invoke

		Result asyncResult = invoker.invoke(invocation);

			AbstractInvoker invoke // this为DubboInvoker
				if (destroyed.get()) {
					logger.warn(
				}

				invocation.setInvoker(this);
				invocation.addObjectAttachmentsIfAbsent(attachment);
				invocation.addObjectAttachments(contextAttachments);
				invocation.setInvokeMode(RpcUtils.getInvokeMode(url, invocation));
					// 同步异步相关-注意异步
					RpcUtils getInvokeMode
						if (inv instanceof RpcInvocation) {
				            RpcInvocation rpcInvocation = (RpcInvocation) inv;
				            if (rpcInvocation.getInvokeMode() != null) {
				                return rpcInvocation.getInvokeMode();
				            }
				        }

				        if (isReturnTypeFuture(inv)) {
				        		// 这种一般是方法返回值为CompletableFuture
					        	Class<?> clazz;
						        if (inv instanceof RpcInvocation) {
						            clazz = ((RpcInvocation) inv).getReturnType();
						        } else {
						            clazz = getReturnType(inv);
						        }
						        return (clazz != null && CompletableFuture.class.isAssignableFrom(clazz)) || isGenericAsync(inv);
				            
				            return InvokeMode.FUTURE;
				        } else if (isAsync(url, inv)) {
				        		// 这种一般是url含有async参数，比如在xml或者注解中配置
					        	boolean isAsync;
						        if (inv instanceof RpcInvocation) {
						            RpcInvocation rpcInvocation = (RpcInvocation) inv;
						            if (rpcInvocation.getInvokeMode() != null) {
						                return rpcInvocation.getInvokeMode() == InvokeMode.ASYNC;
						            }
						        }

						        if (Boolean.TRUE.toString().equals(inv.getAttachment(ASYNC_KEY))) {
						            isAsync = true;
						        } else {
						            isAsync = url.getMethodParameter(getMethodName(inv), ASYNC_KEY, false);
						        }
						        return isAsync;
				            return InvokeMode.ASYNC;
				        } else {
				            return InvokeMode.SYNC;
				        }

				RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);
					// 同步异步相关-注意异步
					// 这个和上面紧密关联的，上面是有可能设置为InvokeMode.FUTURE给inv的

				invocation.put(SERIALIZATION_ID_KEY, serializationId);

				 AsyncRpcResult asyncResult = (AsyncRpcResult) doInvoke(invocation);

					DubboInvoker doInvoke

						inv.setAttachment(PATH_KEY, getUrl().getPath());
						inv.setAttachment(VERSION_KEY, version);

						ExchangeClient currentClient;
				        if (clients.length == 1) {
				            currentClient = clients[0];
				        }

				        boolean isOneway = RpcUtils.isOneway(getUrl(), invocation);
			            int timeout = calculateTimeout(invocation, methodName);
			            	Object countdown = RpcContext.getContext().get(TIME_COUNTDOWN_KEY);
					        int timeout = 1000;
					        if (countdown == null) {
					            timeout = (int) RpcUtils.getTimeout(getUrl(), methodName, RpcContext.getContext(), DEFAULT_TIMEOUT);
					            if (getUrl().getParameter(ENABLE_TIMEOUT_COUNTDOWN_KEY, false)) {
					                invocation.setObjectAttachment(TIMEOUT_ATTACHMENT_KEY, timeout); // pass timeout to remote server
					            }
					        }
			            invocation.put(TIMEOUT_KEY, timeout);

						ExecutorService executor = getCallbackExecutor(getUrl(), inv);

							AbstractInvoker getCallbackExecutor

								if (InvokeMode.SYNC == RpcUtils.getInvokeMode(getUrl(), inv))

									ThreadlessExecutor(ExecutorService sharedExecutor) 

										this.sharedExecutor = sharedExecutor;
								else {
									// 同步异步相关-注意异步
									// 异步调用就是这个，即getInvokeMode不是SYNC
						            return sharedExecutor;
						        }

						CompletableFuture<AppResponse> appResponseFuture =
	                        currentClient.request(inv, timeout, executor).thenApply(obj -> (AppResponse) obj);

								ReferenceCountExchangeClient request

									client.request(request, timeout, executor);

										HeaderExchangeClient request

											channel.request(request, timeout, executor);

												HeaderExchangeChannel request
													 if (closed) {
           												throw new RemotingException

													Request req = new Request();
													req.setTwoWay(true);
													req.setData(request);// request为inv

													DefaultFuture.newFuture(channel, req, timeout, executor);
														
														new DefaultFuture(channel, request, timeout);
															this.channel = channel;
													        this.request = request;
													        this.id = request.getId();
													        this.timeout = timeout > 0 ? timeout : ....
													        FUTURES.put(id, this);
													        CHANNELS.put(id, channel);

														future.setExecutor(executor);
														
														ThreadlessExecutor setWaitingFuture
															this.waitingFuture = waitingFuture; // waitingFuture 为 df
														
														timeoutCheck
															
															TimeoutCheckTask task = new TimeoutCheckTask(future.getId());
																public void run(Timeout timeout) {
														            DefaultFuture future = DefaultFuture.getFuture(requestID);
														            if (future == null || future.isDone()) {
														                return;
														            }

														            if (future.getExecutor() != null) {
														                future.getExecutor().execute(() -> notifyTimeout(future));
														            } else {
														                notifyTimeout(future);
														            }
														        }
        													
        													future.timeoutCheckTask = TIME_OUT_TIMER.newTimeout(task, future.getTimeout(), TimeUnit.MILLISECONDS);
														
														return future;

													channel.send(req) // channel为NettyClient

														AbstractPeer send //  this 为 NettyChannel

															send(message, url.getParameter(Constants.SENT_KEY, false));

																AbstractClient send

																	if (needReconnect && !isConnected())
															            connect();

															        Channel channel = getChannel();
															        	
															        	NettyClient getChannel
															        		
															        		NettyChannel.getOrAddChannel(channel, getUrl(), this);
															       
															        channel.send(message, sent);
															        	
															        	NettyChannel send 
															        	
															        	AbstractChannel send
																		  if (isClosed()) {
            																throw new RemotingException
																		
																		ChannelFuture future = channel.writeAndFlush(message);
																		
																		if (sent) 
																		    timeout = getUrl().getPositiveParameter(TIMEOUT_KEY, DEFAULT_TIMEOUT);
																			success = future.await(timeout);
																		Throwable cause = future.cause();
															            if (cause != null) {
															                throw cause;
															            }
															        if (!success) {
            															throw new RemotingException
													return future;
							
							FutureContext.getContext().setCompatibleFuture(appResponseFuture); // 为了兼容旧版本，不需要关注
			                
			                AsyncRpcResult result = new AsyncRpcResult(appResponseFuture, inv);
			                	this.responseFuture = future;
						        this.invocation = invocation;
						        this.storedContext = RpcContext.getContext();
						        this.storedServerContext = RpcContext.getServerContext();
			                
			                result.setExecutor(executor);
			                	// 这里是ThreadlessExecutor
			                
			                return result;
			    
			    RpcContext.getContext().setFuture(new FutureAdapter(asyncResult.getResponseFuture()));
			    	// 注意异步调用，会使用到这个。会调用recreate->RpcContext.getContext().getFuture
	        	
	        	return asyncResult;            

	    // 同步异步相关-注意异步，异步直接不走下面的if
	    if (InvokeMode.SYNC == ((RpcInvocation) invocation).getInvokeMode()) 

	     	asyncResult.get(Integer.MAX_VALUE, TimeUnit.MILLISECONDS);

	     		if (executor != null && executor instanceof ThreadlessExecutor) {
            		
            		ThreadlessExecutor threadlessExecutor = (ThreadlessExecutor) executor;
            		
            		threadlessExecutor.waitAndDrain();

            			if (finished) {
				            return;
				        }

            			Runnable runnable = queue.take();

            			synchronized (lock) {

            				waiting = false;

            				runnable.run();

            					RunnableWrapper run

            						runnable.run();

            					// eg task1
            					ChannelEventRunnable run
            						
            						if (state == ChannelState.RECEIVED) 
            							
            							handler.received(channel, message);
            								
            								DecodeHandler received
            									
            									if (message instanceof Response)

            										decode(((Response) message).getResult()); // result为DecodeableRpcResult
	            										
	            										if (message instanceof Decodeable) 
		            										
		            										((Decodeable) message).decode();
		            											
		            											DecodeableRpcResult decode
		            												
		            												if (!hasDecoded && channel != null && inputStream != null) {
		            												 	
		            												 	decode(channel, inputStream);
			            												 	
			            												 	byte flag = in.readByte();
	        																
	        																switch (flag) {
	        																
	        																case DubboCodec.RESPONSE_VALUE_WITH_ATTACHMENTS:
				            												 	
				            												 	handleValue(in);
				            												 		
				            												 		Type[] returnTypes = invocation.getReturnTypes();
				            												 		
				            												 		in.readObject((Class<?>) returnTypes[0], returnTypes[1])

				            												 			Hessian2ObjectInput readObject(Class<T> cls, Type type)
				            												 			
				            												 			return readObject(cls);
				            												 		
				            												 		setValue(value); // Annotation, hello world
				            												 			
				            												 			AppResponse setValue // this 为DecodeableRpcResult
				            												 				
				            												 				this.result = value;
				                												
				                												handleAttachment(in);
				                													
				                													addObjectAttachments(in.readAttachments());
				                											if (in instanceof Cleanable) {
																	            ((Cleanable) in).cleanup();
																	            	Hessian2ObjectInput cleanup
																	            		mH2i.reset();
																	        }
		                											finally
		                												hasDecoded = true;

                								handler.received(channel, message);

                									HeaderExchangeHandler received

                										ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);
                										
                										else if (message instanceof Response)
                											
                											handleResponse(channel, (Response) message);
                												
                												DefaultFuture.received(channel, response);
                													received(channel, response, false);
                													
	                													DefaultFuture future = FUTURES.remove(response.getId());
															            if (future != null) {
															                Timeout t = future.timeoutCheckTask;
															                if (!timeout) {
															                    t.cancel();
															                }
															                future.doReceived(response);
															                	if (res.getStatus() == Response.OK) {
            																		this.complete(res.getResult());
	            														finally
	            															CHANNELS.remove(response.getId());

            					// eg task2
            					TimeoutCheckTask#run () -> notifyTimeout(future)

            						Response timeoutResponse = new Response(future.getId());
						            timeoutResponse.setStatus(future.isSent() ? SERVER_TIMEOUT : CLIENT_TIMEOUT);
						            timeoutResponse.setErrorMessage(future.getTimeoutMessage(true));

						            DefaultFuture.received(future.getChannel(), timeoutResponse, true);

            							 DefaultFuture.received(future.getChannel(), timeoutResponse, true);

            							 	DefaultFuture future = FUTURES.remove(response.getId());
            							 	Timeout t = future.timeoutCheckTask;
            							 	if (!timeout) 
            							 		t.cancel();
            							 	future.doReceived(response);

            							 		if (res.getStatus() == Response.OK) {
										            this.complete(res.getResult());
										        } else if (res.getStatus() == Response.CLIENT_TIMEOUT || res.getStatus() == Response.SERVER_TIMEOUT) {
										            this.completeExceptionally(new TimeoutException(res.getStatus() == Response.SERVER_TIMEOUT, channel, res.getErrorMessage()));
										        } else {
										            this.completeExceptionally(new RemotingException(channel, res.getErrorMessage()));
										        }

										        if (threadlessExecutor.isWaiting()) {
               										threadlessExecutor.notifyReturn
            			
        				runnable = queue.poll();
        				while (runnable != null) {
				            runnable.run();
				            runnable = queue.poll();
				        }

				        finished = true;

				    return responseFuture.get(timeout, unit);

        return asyncResult;

        // ====================================================================
        // 另起行结果回流流程如下
        // ====================================================================

ListenerInvokerWrapper invoke
	return invoker.invoke(invocation);


Moniter invoke
	return invoker.invoke(invocation);

	// onResponse的逻辑在provider讲述

FutureFilter invoke
	return invoker.invoke(invocation);

ConsumerContextFilter invoke
	return invoker.invoke(invocation);

InvokerWrapper invoke  // this 为 InvokerDelegate
	return invoker.invoke(invocation);

FailoverClusterInvoker doInvoke
	Result result = invoker.invoke(invocation);
	return result;

AbstractClusterInvoker invoke
	return doInvoke(invocation, invokers, loadbalance);

ClusterInterceptor intercept
	return clusterInvoker.invoke(invocation);

InterceptorInvokerNode invoke
	
	asyncResult = interceptor.intercept(next, invocation);
	
	interceptor.after(next, invocation);
		ConsumerContextClusterInterceptor after
			RpcContext.removeContext(true);
				LOCAL.remove();
				// 	这样保证每次invoke调用，都会清除一次RpcContext 详见dubbo-samples - attachments  这个是consumer端的
	
	asyncResult.whenCompleteWithContext((r, t) -> {
		listener.onMessage(r, clusterInvoker, invocation);
			 RpcContext.getServerContext().setObjectAttachments(appResponse.getObjectAttachments());

MockClusterInvoker invoke
	result = this.invoker.invoke(invocation);
	return result;

MigrationInvoker invoke
	return invoker.invoke(invocation);

InvokerInvocationHandler invoke
	return invoker.invoke(rpcInvocation).recreate();
		AsyncRpcResult recreate

			RpcInvocation rpcInvocation = (RpcInvocation) invocation;

			// 同步异步相关，注意异步
	        if (InvokeMode.FUTURE == rpcInvocation.getInvokeMode()) {
	            
	            return RpcContext.getContext().getFuture();
	            	
	            	return FutureContext.getContext().getCompletableFuture();
	            		
	            		// CompletableFuture<String> future = greetingService.greeting("async call request", SIGNAL);
        				// 调用方执行上面后，回流到如下调用
        				
        				System.out.println("async call returned: " + future.get());
	        }
			
			getAppResponse().recreate();
			 	if (exception != null) {
			 		 try {
		                Object stackTrace = InvokerInvocationHandler.stackTraceField.get(exception);
		                if (stackTrace == null) {
		                    exception.setStackTrace(new StackTraceElement[0]);
		                }
		            } catch (Exception e) {
		                // ignore
		            }
		            throw exception;
		            throw exception;
		        }
		        return result;

AnnotationAction doSayHello
	return helloService.sayHello(name);

AnnotationConsumerBootstrap main
	System.out.println("hello : " + annotationAction.doSayHello("world"));


// ====================================================================
// ====================================================================

客户端接收响应包

// ====================================================================
// ====================================================================


NettyCodecAdapter # InternalDecoder

	InternalDecoder decode(ChannelHandlerContext ctx, ByteBuf input, List<Object> out)

		ChannelBuffer message = new NettyBackedChannelBuffer(input);
			NettyBackedChannelBuffer(ByteBuf buffer)
				this.buffer = buffer;

        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);
        	NettyChannel ret = CHANNEL_MAP.get(ch); // double-check

        do {
            int saveReaderIndex = message.readerIndex();
            	buffer.readerIndex(); // ByteBuf buffer

            Object msg = codec.decode(channel, message);
            	//	另起新开头行

            if (msg == Codec2.DecodeResult.NEED_MORE_INPUT) {
                message.readerIndex(saveReaderIndex);
                break;
            } else {
                //is it possible to go here ?
                if (saveReaderIndex == message.readerIndex()) {
                    throw new IOException("Decode without read data.");
                }
                if (msg != null) {
                    out.add(msg);
                }
            }
        } while (message.readable());

// ====================================================================
DubboCountCodec decode
	
	int save = buffer.readerIndex();

    MultiMessage result = MultiMessage.create();
    	new MultiMessage();
    		private final List messages = new ArrayList();
    
    do {
        Object obj = codec.decode(channel, buffer);
        	//	另起新开头行
        
        if (Codec2.DecodeResult.NEED_MORE_INPUT == obj) {
            buffer.readerIndex(save);
            break;
        } else {

            result.addMessage(obj);
            	
            	messages.add(msg);

            logMessageLength(obj, buffer.readerIndex() - save);
            	
            	else if (result instanceof Response)
            		
            		((AppResponse) ((Response) result).getResult()).setAttachment(OUTPUT_KEY, String.valueOf(bytes));
            		// output -> 55
            
            save = buffer.readerIndex();
        }
    } while (true);

    if (result.isEmpty()) {
        return Codec2.DecodeResult.NEED_MORE_INPUT;
    }

    if (result.size() == 1) {
        return result.get(0);
    }
    return result;

// ====================================================================

ExchangdeCodec decode(Channel channel, ChannelBuffer buffer)
	
	int readable = buffer.readableBytes();
    
    byte[] header = new byte[Math.min(readable, HEADER_LENGTH)];
    
    buffer.readBytes(header);
    	NettyBackedChannelBuffer readBytes
    		buffer.readBytes(dst); // ByteBuf
    
    return decode(channel, buffer, readable, header);

    ExchangdeCodec decode
    	if (readable > 0 && header[0] != MAGIC_HIGH
                || readable > 1 && header[1] != MAGIC_LOW) {
            // ....
        }

    	if (readable < HEADER_LENGTH) {
            return DecodeResult.NEED_MORE_INPUT;
        }

        int len = Bytes.bytes2int(header, 12);
        	
        	return ((b[off + 3] & 0xFF) << 0) +
                ((b[off + 2] & 0xFF) << 8) +
                ((b[off + 1] & 0xFF) << 16) +
                ((b[off + 0]) << 24);
        
        finishRespWhenOverPayload

        checkPayload(channel, len);

        int tt = len + HEADER_LENGTH;
        if (readable < tt) {
            return DecodeResult.NEED_MORE_INPUT;
        }

        ChannelBufferInputStream is = new ChannelBufferInputStream(buffer, len);
	        this.buffer = buffer;
	        startIndex = buffer.readerIndex();
	        endIndex = startIndex + length;
	        buffer.markReaderIndex();

	    return decodeBody(channel, is, header); // this为DubboCodec，进去看DubboCodec重写的 decodeBody 方法

	    	// decodeBody整体逻辑非常复杂，粘贴解析response的部分小部分，具体看源代码
	    	
	    	Response res = new Response(id);

	    	DecodeableRpcResult result = new DecodeableRpcResult(channel, res,
                                    new UnsafeByteArrayInputStream(readMessageData(is)),
                                    (Invocation) getRequestData(id), proto);
                
                readMessageData(InputStream is)
                	
                	if (is.available() > 0) {
                		
                		ChannelBufferInputStream available
                			
                			return endIndex - buffer.readerIndex();
                	
                	byte[] result = new byte[is.available()];
		            
		            is.read(result);
		            	
		            	ChannelBufferInputStream read(byte[] b, int off, int len)
			            	
			            	int available = available();
					        
					        if (available == 0) {
					            return -1;
					        }
					        
					        len = Math.min(available, len);
					        
					        buffer.readBytes(b, off, len);
					        	
					        	NettyBackedChannelBuffer readBytes(byte[] dst, int dstIndex, int length)
					        		
					        		buffer.readBytes(dst, dstIndex, length); // byteBuf
					        
					        return len;
		            
		            return result;

		        UnsafeByteArrayInputStream
		        	this(buf, 0, buf.length);
			        	mData = buf;
	        			mPosition = mMark = offset;
	       				mLimit = Math.min(offset + length, buf.length);


	       		protected Object getRequestData(long id) {
			        DefaultFuture future = DefaultFuture.getFuture(id);
			        if (future == null) {
			            return null;
			        }
			        Request req = future.getRequest();
			        if (req == null) {
			            return null;
			        }
			        return req.getData();
			    }

            res.setResult(data);

        finally 
	        if (is.available() > 0) {
	            try {
	                StreamUtils.skipUnusedStream(is);
	                	if (is.available() > 0) {
				            is.skip(is.available());
				        }
	            } catch (IOException e) {
	                logger.warn(e.getMessage(), e);
	            }
	        }

NettyClientHandler channelRead
	NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);
    handler.received(channel, msg); // handler为NettyClient

	AbstractPeer received // this为NettyClient
		if (closed) {
            return;
        }

		handler.received(ch, msg); 

			MultiMessageHandler received

				if (message instanceof MultiMessage) {
		            MultiMessage list = (MultiMessage) message;
		            for (Object obj : list) {
		                handler.received(channel, obj);
		            }
		        } else {
		            handler.received(channel, message);

		            	HeartbeatHandler received

		            		setReadTimestamp(channel);

		            		if (isHeartbeatRequest(message)) {

		            		if (isHeartbeatResponse(message)) {

		            			handler.received(channel, message);

		            				AllChannelHandler received

		            					ExecutorService executor = getPreferredExecutorService(message);

		            						WrappedChannelHandler getPreferredExecutorService

		            							if (msg instanceof Response) {
										            Response response = (Response) msg;
										            DefaultFuture responseFuture = DefaultFuture.getFuture(response.getId());
										            if (responseFuture == null) {
										                return getSharedExecutorService();
										            } else {
										                ExecutorService executor = responseFuture.getExecutor();
										                if (executor == null || executor.isShutdown()) {
										                    executor = getSharedExecutorService();
										                }
										                // ThreadlessExecutor
										                return executor;
										            }
										        } else {
										        	return getSharedExecutorService();
										        }

		            					executor.execute(new ChannelEventRunnable(channel, handler, RECEIVED, message));

		            						ThreadlessExecutor execute(Runnable runnable)

		            							runnable = new RunnableWrapper(runnable);

		            							synchronized (lock) {

		            							 	queue.add(runnable);

		            							 	// 后续过程在前面讲到了就是AsyncToSync的result.get()操作

// ====================================================================
// ====================================================================

下面是client写server 

// ====================================================================
// ====================================================================

NettyClientHandler write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)

	super.write(ctx, msg, promise);
	// 另起新开头行

	final NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);
    
    final boolean isRequest = msg instanceof Request;
    
    promise.addListener(future -> {
        
        if (future.isSuccess()) {
            
            handler.sent(channel, msg);

            	AbstractPeer sent(Channel ch, Object msg) // this 为NettyClient
            		
            		if (closed) 
            			return;
            		
            		handler.sent(ch, msg); // handler 为MultiMessageHandler
            			
            			AbstractChannelHandlerDelegate	sent // this为MultiMessageHandler
            				
            				handler.sent(channel, message); // handler 为 HeartbeatHandler
            					
            					setWriteTimestamp(channel);
            						channel.setAttribute(KEY_WRITE_TIMESTAMP, System.currentTimeMillis());
            							NettyChannel setAttribute(String key, Object value)
            								attributes.put(key, value);
        						
        						handler.sent(channel, message); // handler为DecodeHandler
        							
        							AbstractChannelHandlerDelegate	sent
        							 	
        							 	handler.sent(channel, message); // handler为HeaderExchangeHandler
        							 		
        							 		HeaderExchangeHandler sent(Channel channel, Object message) 
	        							 		
	        							 		ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);
									            
									            handler.sent(exchangeChannel, message); // handler为requestHandler
									            	ChannelHandlerAdapter sent
									            		// 空
									            
									            if (message instanceof Request) {
										            
										            Request request = (Request) message;
										            
										            DefaultFuture.sent(channel, request);	
										            	
										            	FUTURES.get(request.getId()).doSent();
										            		
										            		DefaultFuture doSent
										            			
										            			sent = System.currentTimeMillis();
										            			
										            			// 记录sent是为了区分是客户端超时还是服务端超时
										            			// 注意getTimeoutMessage方法的调用点 和 isSent 方法

        }

        Throwable t = future.cause();
        if (t != null && isRequest) {
            Request request = (Request) msg;
            Response response = buildErrorResponse(request, t);
            	Response response = new Response(request.getId(), request.getVersion());
		        response.setStatus(Response.BAD_REQUEST);
		        response.setErrorMessage(StringUtils.toString(t));
		        return response;
            handler.received(channel, response);
            // 	HeaderExchangeHandler received
            		handleResponse(channel, (Response) message);
            			DefaultFuture.received(channel, response);
            				doReceived(Response res)
            					this.completeExceptionally(new RemotingException(channel, res.getErrorMessage()));

        }
    });

InternalEncoder encode(ChannelHandlerContext ctx, Object msg, ByteBuf out)

	ChannelBuffer buffer = new NettyBackedChannelBuffer(out);
		NettyBackedChannelBuffer(ByteBuf buffer)
			this.buffer = buffer;
	
	NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);
	
	codec.encode(channel, buffer, msg);

		DubboCountCodec encode 

			codec.encode(channel, buffer, msg);

				ExchangeCodec encode

					if (msg instanceof Request) 
            			
            			encodeRequest(channel, buffer, (Request) msg);

            				Serialization serialization = getSerialization(channel, req);
            					AbstractCodec getSerialization
            						return CodecSupport.getSerialization(channel.getUrl());

            				byte[] header = new byte[HEADER_LENGTH];
					        
					        Bytes.short2bytes(MAGIC, header);
					        	b[off + 1] = (byte) v;
        						b[off + 0] = (byte) (v >>> 8);

					        header[2] = (byte) (FLAG_REQUEST | serialization.getContentTypeId());
					        	Hessian2Serialization getContentTypeId
						        	return HESSIAN2_SERIALIZATION_ID;
						        		 byte HESSIAN2_SERIALIZATION_ID = 2;
					        
					        if (req.isTwoWay()) {
					            header[2] |= FLAG_TWOWAY;
					        }
					        
					        if (req.isEvent()) {
					            header[2] |= FLAG_EVENT;
					        }

					        Bytes.long2bytes(req.getId(), header, 4);
					        	
					        	Bytes long2bytes(long v, byte[] b, int off)
						        	
						        	b[off + 7] = (byte) v;
							        b[off + 6] = (byte) (v >>> 8);
							        b[off + 5] = (byte) (v >>> 16);
							        b[off + 4] = (byte) (v >>> 24);
							        b[off + 3] = (byte) (v >>> 32);
							        b[off + 2] = (byte) (v >>> 40);
							        b[off + 1] = (byte) (v >>> 48);
							        b[off + 0] = (byte) (v >>> 56);

					        // encode request data.
					        int savedWriteIndex = buffer.writerIndex();
					        	return buffer.writerIndex();

					        buffer.writerIndex(savedWriteIndex + HEADER_LENGTH);
					        	buffer.writerIndex(writerIndex);
					       
					        ChannelBufferOutputStream bos = new ChannelBufferOutputStream(buffer);
					        	ChannelBufferOutputStream(ChannelBuffer buffer)
					        		this.buffer = buffer;
        							startIndex = buffer.writerIndex();

        					if (req.isHeartbeat()) {
        						// ...
        					else
        						ObjectOutput out = serialization.serialize(channel.getUrl(), bos);
        							Hessian2Serialization serialize(URL url, OutputStream out)
        								return new Hessian2ObjectOutput(out);
        									mH2o = OUTPUT_TL.get();
        									mH2o.init(os);
	        					
	        					if (req.isEvent()) {
	        						// .....
					            } else {
					                encodeRequestData(channel, out, req.getData(), req.getVersion());
					                // 另起开头，走 DubboCodec
					            }

					            out.flushBuffer();
					            	 mH2o.flushBuffer();
					           	
					           	if (out instanceof Cleanable) {
	                				((Cleanable) out).cleanup();
	                					Hessian2ObjectOutput cleanup
	                						mH2o.reset();

                			bos.flush();
					        bos.close();
					        
					        int len = bos.writtenBytes();
					        	 return buffer.writerIndex() - startIndex;
					        
					        checkPayload(channel, len);
					        
					        Bytes.int2bytes(len, header, 12);
					        	Bytes public static void int2bytes(int v, byte[] b, int off) {
							        b[off + 3] = (byte) v;
							        b[off + 2] = (byte) (v >>> 8);
							        b[off + 1] = (byte) (v >>> 16);
							        b[off + 0] = (byte) (v >>> 24);
							    }

					        // write
					        buffer.writerIndex(savedWriteIndex);
					        buffer.writeBytes(header); // write header.
						        NettyBackedChannelBuffer writeBytes(byte[] src)
						        	buffer.writeBytes(src);
					        buffer.writerIndex(savedWriteIndex + HEADER_LENGTH + len);

// ====================================================================
DubboCodec encodeRequestData(Channel channel, ObjectOutput out, Object data, String version) 
	RpcInvocation inv = (RpcInvocation) data;

    out.writeUTF(version);
    	Hessian2ObjectOutput writeUTF(String v)
    		mH2o.writeString(v);
    
    String serviceName = inv.getAttachment(INTERFACE_KEY);
    	Object value = attachments.get(key);
    	if (value instanceof String) {
            return (String) value;
   
    if (serviceName == null) {
        serviceName = inv.getAttachment(PATH_KEY);
    }
    
    out.writeUTF(serviceName);
    out.writeUTF(inv.getAttachment(VERSION_KEY));

    out.writeUTF(inv.getMethodName());
    out.writeUTF(inv.getParameterTypesDesc());
    Object[] args = inv.getArguments();
    if (args != null) {
        for (int i = 0; i < args.length; i++) {
            out.writeObject(encodeInvocationArgument(channel, inv, i));
            	Hessian2ObjectOutput writeObject(Object obj)
            		mH2o.writeObject(obj);
        }
    }
    out.writeAttachments(inv.getObjectAttachments());
    	Hessian2ObjectOutput writeAttachments(Map<String, Object> attachments)
    		writeObject(attachments);

// ====================================================================
// ====================================================================
	server 接受client请求并回传响应
// ====================================================================
// ====================================================================

InternalDecoder decode // 参考前面 client 接受 server 响应的过程

DubboCountCodec decode // 参考前面 client 接受 server 响应的过程

ExchangeCodec decode // 参考前面 client 接受 server 响应的过程

DubboCodec decodeBody // 参考前面 client 接受 server 响应的过程
	//...
	else{
		Request req = new Request(id);
        req.setVersion(Version.getProtocolVersion());
        req.setTwoWay((flag & FLAG_TWOWAY) != 0);
        if ((flag & FLAG_EVENT) != 0) {
            req.setEvent(true);
        }
        Object data;
        if (req.isEvent()) {
        	//...
        }else{
			DecodeableRpcInvocation inv;
            if (channel.getUrl().getParameter(DECODE_IN_IO_THREAD_KEY, DEFAULT_DECODE_IN_IO_THREAD)) {
                inv = new DecodeableRpcInvocation(channel, req, is, proto);
                inv.decode();
            } else {
                inv = new DecodeableRpcInvocation(channel, req,
                        new UnsafeByteArrayInputStream(readMessageData(is)), proto);
            }
            data = inv;
        }
        req.setData(data);
		
	}

NettyServerHandler channelRead

	NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);
    
    handler.received(channel, msg); // handler为NettyServer
    	
    	AbstractPeer received
    		if (closed) {
            	return;
            
            handler.received(ch, msg);

				MultiMessageHandler received

					HeartbeatHandler received
						setReadTimestamp(channel);

						AllChannelHandler received
							ExecutorService executor = getPreferredExecutorService(message);
								WrappedChannelHandler getPreferredExecutorService
									if (msg instanceof Response) {
									else {
	            						return getSharedExecutorService();
	            							executorRepository.getExecutor(url);
	            								DefaultExecutorRepository getExecutor
	            									return data.get(EXECUTOR_SERVICE_COMPONENT_KEY).get(portKey);
							
							executor.execute(new ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message));
							// 另起一行

DecodeHandler received
	
	if (message instanceof Request) {
        
        decode(((Request) message).getData());
			
			DecodeHandler decode
				
				((Decodeable) message).decode();
					
					DecodeableRpcInvocation decode
						
						if (!hasDecoded && channel != null && inputStream != null) {
							
							decode(channel, inputStream);
								
								ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), serializationType)
						                .deserialize(channel.getUrl(), input);
							                CodecSupport getSerialization
							                	return getSerializationById(id);
							                		 return ID_SERIALIZATION_MAP.get(id);
							            Hessian2Serialization deserialize(URL url, InputStream is)    		 
							            	return new Hessian2ObjectInput(is);

						        this.put(SERIALIZATION_ID_KEY, serializationType);

						        String dubboVersion = in.readUTF();
						        request.setVersion(dubboVersion);
						        setAttachment(DUBBO_VERSION_KEY, dubboVersion);

						        String path = in.readUTF();
						        setAttachment(PATH_KEY, path);
						        String version = in.readUTF();
						        setAttachment(VERSION_KEY, version);
						        setMethodName(in.readUTF());

						        String desc = in.readUTF();
						        setParameterTypesDesc(desc);
						        
						        Object[] args = DubboCodec.EMPTY_OBJECT_ARRAY;
            					Class<?>[] pts = DubboCodec.EMPTY_CLASS_ARRAY;
						        
						        if (desc.length() > 0) { //  Ljava/lang/String;
						        	ServiceRepository repository = ApplicationModel.getServiceRepository();
					                ServiceDescriptor serviceDescriptor = repository.lookupService(path);
					                if (serviceDescriptor != null) {
					                    MethodDescriptor methodDescriptor = serviceDescriptor.getMethod(getMethodName(), desc);
					                    if (methodDescriptor != null) {
					                        pts = methodDescriptor.getParameterClasses();
					                        this.setReturnTypes(methodDescriptor.getReturnTypes());
					                    }
					                }
					                args = new Object[pts.length];
					                for (int i = 0; i < args.length; i++) {
					                    try {
					                        args[i] = in.readObject(pts[i]);
					            
					            setParameterTypes(pts);
					            setArguments(args);
					            
					            setObjectAttachments(in.readAttachments(););
					            
					            setTargetServiceUniqueName(targetServiceName);
					            
					            if (in instanceof Cleanable) {
					                ((Cleanable) in).cleanup();
					                	mH2i.reset();

							hasDecoded = true;

	handler.received(channel, message);
	// 另起一行


HeaderExchangeHandler received
	
	final ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);
	        
	        if (message instanceof Request) {
	            
	            Request request = (Request) message;
	            if (request.isEvent()) {
	           		// ....
	            } else {
	                if (request.isTwoWay()) {
	                    
	                    handleRequest(exchangeChannel, request);
	                    	
	                    	Response res = new Response(req.getId(), req.getVersion());
	                    	if (req.isBroken()) {
	                    		// ....
	                    		return;
	                    	}
	                    	
	                    	Object msg = req.getData();
	                    	CompletionStage<Object> future = handler.reply(channel, msg);

	                    		requestHandler reply(ExchangeChannel channel, Object message)

	                    			Invocation inv = (Invocation) message;
            						Invoker<?> invoker = getInvoker(channel, inv);
	            						String serviceKey = serviceKey(
								                channel.getLocalAddress().getPort(),
								                (String) inv.getObjectAttachments().get(PATH_KEY),
								                (String) inv.getObjectAttachments().get(VERSION_KEY),
								                (String) inv.getObjectAttachments().get(GROUP_KEY)
								        );
								        DubboExporter<?> exporter = (DubboExporter<?>) exporterMap.get(serviceKey);
								        return exporter.getInvoker();
								        	AbstractExporter getInvoker
								        		return invoker; // FilterNode

				            		RpcContext.getContext().setRemoteAddress(channel.getRemoteAddress());
						            
						            Result result = invoker.invoke(inv);
						            	// 另起一行 见 FilterNode invoke

						            return result.thenApply(Function.identity());

				            future.whenComplete((appResult, t) -> {
				                try {
				                    if (t == null) {
				                        res.setStatus(Response.OK);
				                        res.setResult(appResult);
				                    } else {
				                        res.setStatus(Response.SERVICE_ERROR);
				                        res.setErrorMessage(StringUtils.toString(t));
				                    }

				                    channel.send(res);

				                    	HeaderExchangeChannel send

				                    		if (closed) {
									            throw new RemotingException
									        }
									        if (message instanceof Request
									                || message instanceof Response
									                || message instanceof String) {
									            channel.send(message, sent);
									        } else {
									            Request request = new Request();
									            request.setVersion(Version.getProtocolVersion());
									            request.setTwoWay(false);
									            request.setData(message);
									            channel.send(request, sent);
									        }

					                    		NettyChannel send
													super.send(message, sent);
											        boolean success = true;
											        int timeout = 0;
											        try {
											            ChannelFuture future = channel.writeAndFlush(message);
											            if (sent) {
											                timeout = getUrl().getPositiveParameter(TIMEOUT_KEY, DEFAULT_TIMEOUT);
											                success = future.await(timeout);
											            }
											            Throwable cause = future.cause();
											            if (cause != null) {
											                throw cause;
											            }
											        } catch (Throwable e) {
											            removeChannelIfDisconnected(channel);
											            throw new RemotingException(this, ....);
											        }
											        if (!success) {
											            throw new RemotingException(this,....);
											        }

				                } catch (RemotingException e) {
				                    logger.warn("Send result to consumer failed, channel is " + channel + ", msg is " + e);
				                }
				            });
// ====================================================================
服务端从 requestHandler#reply 的 Result result = invoker.invoke(inv);触发点开始，调用本地方法的过程如下

FilterNode invoke
	asyncResult = filter.invoke(next, invocation);
		ContextFilter invoke

			Map<String, Object> attachments = invocation.getObjectAttachments();
	        if (attachments != null) {
	            Map<String, Object> newAttach = new HashMap<>(attachments.size());
	            for (Map.Entry<String, Object> entry : attachments.entrySet()) {
	                String key = entry.getKey();
	                if (!UNLOADING_KEYS.contains(key)) {
	                    newAttach.put(key, entry.getValue());
	                }
	            }
	            attachments = newAttach;
	        }

	        RpcContext context = RpcContext.getContext();
	        context.setInvoker(invoker)
	                .setInvocation(invocation)
	                .setLocalAddress(invoker.getUrl().getHost(), invoker.getUrl().getPort());
	            	.setRemoteApplicationName(invocation.getAttachment(REMOTE_APPLICATION_KEY));

	        long timeout = RpcUtils.getTimeout(invocation, -1);
	        if (timeout != -1) {
	            context.set(TIME_COUNTDOWN_KEY, TimeoutCountDown.newCountDown(timeout, TimeUnit.MILLISECONDS));
	        }

	        if (attachments != null) {
	            if (context.getObjectAttachments() != null) {
	                context.getObjectAttachments().putAll(attachments);
	            } else {
	                context.setObjectAttachments(attachments);
	            }
	        }

	        if (invocation instanceof RpcInvocation) {
	            ((RpcInvocation) invocation).setInvoker(invoker);
	        }

	        try {
	            context.clearAfterEachInvoke(false);
	            	// 默认值为true
	            	this.remove = remove;
	            return invoker.invoke(invocation);
	            	// 另换行
	        } finally {
	            context.clearAfterEachInvoke(true);
	            // 注意这句话，每次invoke完成后都会清空RpcContext
	            // IMPORTANT! For async scenario, we must remove context from current thread, so we always create a new RpcContext for the next invoke for the same thread.
	            RpcContext.removeContext(true);
	            RpcContext.removeServerContext();
	            	SERVER_LOCAL.remove();
	        }

FilterNode invoke
	asyncResult = filter.invoke(next, invocation);
		
		EchoFilter	invoke
			if (inv.getMethodName().equals($ECHO) && inv.getArguments() != null && inv.getArguments().length == 1) {
	            return AsyncRpcResult.newDefaultAsyncResult(inv.getArguments()[0], inv);
	            	AsyncRpcResult newDefaultAsyncResult(Object value, Invocation invocation) 
	            		return newDefaultAsyncResult(value, null, invocation);
	            			CompletableFuture<AppResponse> future = new CompletableFuture<>();
					        AppResponse result = new AppResponse(invocation);
					        if (t != null) {
					            result.setException(t);
					        } else {
					            result.setValue(value);
					        }
					        future.complete(result);
					        return new AsyncRpcResult(future, invocation);
	        }
	        return invoker.invoke(inv);

FilterNode invoke
	asyncResult = filter.invoke(next, invocation);
		
		ClassLoaderFilter invoke
			ClassLoader ocl = Thread.currentThread().getContextClassLoader();
	        Thread.currentThread().setContextClassLoader(invoker.getInterface().getClassLoader());
	        try {
	            return invoker.invoke(invocation);
	        } finally {
	            Thread.currentThread().setContextClassLoader(ocl);
	        }

FilterNode invoke
	asyncResult = filter.invoke(next, invocation);
		
		GenericFilter invoke
			if ((inv.getMethodName().equals($INVOKE) || inv.getMethodName().equals($INVOKE_ASYNC)){

			}
			return invoker.invoke(inv);

FilterNode invoke
	asyncResult = filter.invoke(next, invocation);	
		
		TraceFilter invoke
			//...
			Result result = invoker.invoke(invocation);
			//...

FilterNode invoke
	asyncResult = filter.invoke(next, invocation);	

		TimeoutFilter invoke
			return invoker.invoke(invocation);


FilterNode invoke
	asyncResult = filter.invoke(next, invocation);	

		MonitorFilter invoke 
			if (invoker.getUrl().hasParameter(MONITOR_KEY)) {
				invocation.put(MONITOR_FILTER_START_TIME, System.currentTimeMillis());
	            invocation.put(MONITOR_REMOTE_HOST_STORE, RpcContext.getContext().getRemoteHost());
	            getConcurrent(invoker, invocation).incrementAndGet(); // count up
			}
			return invoker.invoke(invocation); // proceed invocation chain

FilterNode invoke
	asyncResult = filter.invoke(next, invocation);		
		
		ExceptionFilter invoke
			return invoker.invoke(invocation);

InvokerWrapper invoke // this 为 RegistryProtocol#InvokerDelegate

	DelegateProviderMetaDataInvoker invoke	

		AbstractProxyInvoker invoke // this 为javassist生成的 注意 proxy 为DemoServiceImpl
			try {
				Object value = doInvoke(proxy, invocation.getMethodName(), invocation.getParameterTypes(), invocation.getArguments());

					JavassistProxyFactory$1 doInvoke
						wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);
							AnnotationHelloServiceImpl	sayHello

	            CompletableFuture<Object> future = wrapWithFuture(value);
	            	
	            	// 这个异步适用于provider，怎么应用的，请看dubbo-samples的async-provider测试用例
	            	if (RpcContext.getContext().isAsyncStarted()) {
			            
			            return ((AsyncContextImpl)(RpcContext.getContext().getAsyncContext())).getInternalFuture();
			            	
			            	CompletableFuture<Object> getInternalFuture() {
       							return future;
			        } else if (value instanceof CompletableFuture) {
			            
			            return (CompletableFuture<Object>) value;
			        }	
			        	// 截取samples的案例
			        	AsyncContext asyncContext = RpcContext.startAsync();
			        		
			        		RpcContext currentContext = getContext();
					        
					        if (currentContext.asyncContext == null) {
					            currentContext.asyncContext = new AsyncContextImpl();
					        }
					        
					        currentContext.asyncContext.start();
					        	AsyncContextImpl start
						        	if (this.started.compareAndSet(false, true)) {
							            this.future = new CompletableFuture<>();
							        }
					        
					        return currentContext.asyncContext;

				        logger.info("sayHello start");

				        new Thread(() -> {
				            
				            asyncContext.signalContextSwitch();
				            	RpcContext.restoreContext(storedContext);
				            		LOCAL.set(oldContext);
        						RpcContext.restoreServerContext(storedServerContext);
        							SERVER_LOCAL.set(oldServerContext);
				            
				            logger.info("Attachment from consumer: " + RpcContext.getContext().getAttachment("consumer-key1"));
				            logger.info("async start");
				            try {
				                Thread.sleep(5000);
				            } catch (InterruptedException e) {
				                e.printStackTrace();
				            }
				            
				            asyncContext.write("Hello " + name + ", response from provider.");
				            	AsyncContextImpl write
					            	if (isAsyncStarted() && stop()) {
							            if (value instanceof Throwable) {
							                Throwable bizExe = (Throwable) value;
							                future.completeExceptionally(bizExe);
							            } else {
							                future.complete(value);
							            }
							        } else {
							            throw new IllegalStateException("The async response has probably been wrote back by another thread, or the asyncContext has been closed.");
							        }
							        
							        isAsyncStarted() && stop()	
								        return started.get();
								        return stopped.compareAndSet(false, true);

				            logger.info("async end");
				        }).start();

				        logger.info("sayHello end");
				        return "hello, " + name;


			        // 一般是直接走到这里
			        return CompletableFuture.completedFuture(value);

	            CompletableFuture<AppResponse> appResponseFuture = future.handle((obj, t) -> {
	                AppResponse result = new AppResponse(invocation);
	                	this.setAttribute(INVOCATION_KEY, invocation);
	                		attributes.put(key, value);
	                if (t != null) {
	                    if (t instanceof CompletionException) {
	                        result.setException(t.getCause());
	                    } else {
	                        result.setException(t);
	                    }
	                } else {
	                	// 走这里
	                    result.setValue(obj);
	                    	AppResponse setValue(Object value)
	                    		this.result = value;
	                }
	                return result;
	            });
	            return new AsyncRpcResult(appResponseFuture, invocation);
	            	this.responseFuture = future;
			        this.invocation = invocation;
			        this.storedContext = RpcContext.getContext();
			        this.storedServerContext = RpcContext.getServerContext();

			}
			        
		    catch (InvocationTargetException e) {
	            if (RpcContext.getContext().isAsyncStarted() && !RpcContext.getContext().stopAsync()) {
	                logger.error("Provider async started, but got an exception from the original method, cannot write the exception back to consumer because an async result may have returned the new thread.", e);
	            }
	            return AsyncRpcResult.newDefaultAsyncResult(null, e.getTargetException(), invocation);
	        } catch (Throwable e) {
	            throw new RpcException("Failed to invoke remote proxy method " + invocation.getMethodName() + " to " + getUrl() + ", cause: " + e.getMessage(), e);
	        }
// ====================================================================
// 结果回流过程如下
FilterNode invoke
	try{
		asyncResult = filter.invoke(next, invocation);	
	}catch(){
		// .... 
	}

	return asyncResult.whenCompleteWithContext((r, t) -> {
            // .....
        });

        AsyncRpcResult	whenCompleteWithContext
		    
		    this.responseFuture = this.responseFuture.whenComplete((v, t) -> {
	            
	            beforeContext.accept(v, t);
	            	tmpContext = RpcContext.getContext();
			        tmpServerContext = RpcContext.getServerContext();
			        RpcContext.restoreContext(storedContext);
			        RpcContext.restoreServerContext(storedServerContext);
	            
	            fn.accept(v, t);
	            	if (filter instanceof ListenableFilter) {
		                // .....
		            } else if (filter instanceof Filter.Listener) {
		                Filter.Listener listener = (Filter.Listener) filter;
		                if (t == null) {
		                    listener.onResponse(r, invoker, invocation);
		                    	ExceptionFilter	onResponse
		                    		// 另起行
		                } else {
		                    listener.onError(t, invoker, invocation);
		                }
		            }
	            
	            afterContext.accept(v, t);
	            	RpcContext.restoreContext(tmpContext);
        			RpcContext.restoreServerContext(tmpServerContext);
	        });


ExceptionFilter	onResponse
	if (appResponse.hasException() && GenericService.class != invoker.getInterface()) {
        try {
            Throwable exception = appResponse.getException();

            // directly throw if it's checked exception
            if (!(exception instanceof RuntimeException) && (exception instanceof Exception)) {
                return;
            }
            // directly throw if the exception appears in the signature
            try {
                Method method = invoker.getInterface().getMethod(invocation.getMethodName(), invocation.getParameterTypes());
                Class<?>[] exceptionClasses = method.getExceptionTypes();
                for (Class<?> exceptionClass : exceptionClasses) {
                    if (exception.getClass().equals(exceptionClass)) {
                        return;
                    }
                }
            } catch (NoSuchMethodException e) {
                return;
            }

            // for the exception not found in method's signature, print ERROR message in server's log.
            logger.error("Got unchecked and undeclared exception which called by " + RpcContext.getContext().getRemoteHost() + ". service: " + invoker.getInterface().getName() + ", method: " + invocation.getMethodName() + ", exception: " + exception.getClass().getName() + ": " + exception.getMessage(), exception);

            // directly throw if exception class and interface class are in the same jar file.
            String serviceFile = ReflectUtils.getCodeBase(invoker.getInterface());
            String exceptionFile = ReflectUtils.getCodeBase(exception.getClass());
            if (serviceFile == null || exceptionFile == null || serviceFile.equals(exceptionFile)) {
                return;
            }
            // directly throw if it's JDK exception
            String className = exception.getClass().getName();
            if (className.startsWith("java.") || className.startsWith("javax.")) {
                return;
            }
            // directly throw if it's dubbo exception
            if (exception instanceof RpcException) {
                return;
            }

            // otherwise, wrap with RuntimeException and throw back to the client
            appResponse.setException(new RuntimeException(StringUtils.toString(exception)));
	            StringUtils toString
	            	UnsafeStringWriter w = new UnsafeStringWriter();
			        PrintWriter p = new PrintWriter(w);
			        p.print(e.getClass().getName());
			        if (e.getMessage() != null) {
			            p.print(": " + e.getMessage());
			        }
			        p.println();
			        try {
			            e.printStackTrace(p);
			            return w.toString();
			        } finally {
			            p.close();
			        }
        } catch (Throwable e) {
            logger.warn("Fail to ExceptionFilter when called by " + RpcContext.getContext().getRemoteHost() + ". service: " + invoker.getInterface().getName() + ", method: " + invocation.getMethodName() + ", exception: " + e.getClass().getName() + ": " + e.getMessage(), e);
        }
    }

FilterNode invoke
	
	asyncResult = filter.invoke(next, invocation);

	return asyncResult.whenCompleteWithContext((r, t) -> {
        // ..... 参考前面，直接讲 MonitorFilter onResponse
    });

	MonitorFilter onResponse

	if (invoker.getUrl().hasParameter(MONITOR_KEY)) {
        
        collect(invoker, invocation, result, (String) invocation.get("monitor_remote_host_store"), (long) invocation.get("monitor_filter_start_time"), false);
        	
        	MonitorFilter collect

        		URL monitorUrl = invoker.getUrl().getUrlParameter(MONITOR_KEY);
	            
	            Monitor monitor = monitorFactory.getMonitor(monitorUrl);

	            	 	url = url.setPath(MonitorService.class.getName()).addParameter(INTERFACE_KEY, 	MonitorService.class.getName());
				        String key = url.toServiceStringWithoutResolving();
				        
				        Monitor monitor = MONITORS.get(key);
				        Future<Monitor> future = FUTURES.get(key);
				        if (monitor != null || future != null) {
				            return monitor;
				        }

				        LOCK.lock();
				        try {
				            monitor = MONITORS.get(key);
				            future = FUTURES.get(key);
				            if (monitor != null || future != null) {
				                return monitor;
				            }

				            final URL monitorUrl = url;
				            
				            final CompletableFuture<Monitor> completableFuture = CompletableFuture.supplyAsync(() -> AbstractMonitorFactory.this.createMonitor(monitorUrl));
				            	
				            	DubboMonitorFactory createMonitor
				            		URLBuilder urlBuilder = URLBuilder.from(url);
							        urlBuilder.setProtocol(url.getParameter(PROTOCOL_KEY, DUBBO_PROTOCOL));
							        String filter = url.getParameter(REFERENCE_FILTER_KEY);
							        if (StringUtils.isEmpty(filter)) {
							            filter = "";
							        } else {
							            filter = filter + ",";
							        }
							        urlBuilder.addParameters(CHECK_KEY, String.valueOf(false),
							                REFERENCE_FILTER_KEY, filter + "-monitor");

							        Invoker<MonitorService> monitorInvoker = protocol.refer(MonitorService.class, urlBuilder.build());
							        
							        MonitorService monitorService = proxyFactory.getProxy(monitorInvoker);
							        
							        return new DubboMonitor(monitorInvoker, monitorService);
							        	this.monitorInvoker = monitorInvoker;
								        this.monitorService = monitorService;
								        final long monitorInterval = monitorInvoker.getUrl().getPositiveParameter("interval", 60000);
								        sendFuture = scheduledExecutorService.scheduleWithFixedDelay(() -> {
								                send();
								                // todo 
								        }, monitorInterval, monitorInterval, TimeUnit.MILLISECONDS);
				            
				            FUTURES.put(key, completableFuture);
				            
				            completableFuture.thenRunAsync(new MonitorListener(key), EXECUTOR);
				            	
				            	MonitorListener	run
					            	CompletableFuture<Monitor> completableFuture = AbstractMonitorFactory.FUTURES.get(key);
					                AbstractMonitorFactory.MONITORS.put(key, completableFuture.get());
					                AbstractMonitorFactory.FUTURES.remove(key);

				            return null;
				        } finally {
				            // unlock
				            LOCK.unlock();
				        }

	            if (monitor == null) {
	                return;
	            }
	            
	            URL statisticsURL = createStatisticsUrl(invoker, invocation, result, remoteHost, start, error);

		            long elapsed = System.currentTimeMillis() - start; // invocation cost
			        int concurrent = getConcurrent(invoker, invocation).get(); // current concurrent count
			        String application = invoker.getUrl().getParameter(APPLICATION_KEY);
			        String service = invoker.getInterface().getName(); // service name
			        String method = RpcUtils.getMethodName(invocation); // method name
			        String group = invoker.getUrl().getParameter(GROUP_KEY);
			        String version = invoker.getUrl().getParameter(VERSION_KEY);

			        int localPort;
			        String remoteKey, remoteValue;
			        if (CONSUMER_SIDE.equals(invoker.getUrl().getParameter(SIDE_KEY))) {
			            // ---- for service consumer ----
			            localPort = 0;
			            remoteKey = MonitorService.PROVIDER;
			            remoteValue = invoker.getUrl().getAddress();
			        } else {
			            // ---- for service provider ----
			            localPort = invoker.getUrl().getPort();
			            remoteKey = MonitorService.CONSUMER;
			            remoteValue = remoteHost;
			        }
			        String input = "", output = "";
			        if (invocation.getAttachment(INPUT_KEY) != null) {
			            input = invocation.getAttachment(INPUT_KEY);
			        }
			        if (result != null && result.getAttachment(OUTPUT_KEY) != null) {
			            output = result.getAttachment(OUTPUT_KEY);
			        }

			        return new URL(COUNT_PROTOCOL, NetUtils.getLocalHost(), localPort, service + PATH_SEPARATOR + method, MonitorService.APPLICATION, application, MonitorService.INTERFACE, service, MonitorService.METHOD, method, remoteKey, remoteValue, error ? MonitorService.FAILURE : MonitorService.SUCCESS, "1", MonitorService.ELAPSED, String.valueOf(elapsed), MonitorService.CONCURRENT, String.valueOf(concurrent), INPUT_KEY, input, OUTPUT_KEY, output, GROUP_KEY, group, VERSION_KEY, version);
			    
	            monitor.collect(statisticsURL);
		            int success = url.getParameter(MonitorService.SUCCESS, 0);
			        int failure = url.getParameter(MonitorService.FAILURE, 0);
			        int input = url.getParameter(MonitorService.INPUT, 0);
			        int output = url.getParameter(MonitorService.OUTPUT, 0);
			        int elapsed = url.getParameter(MonitorService.ELAPSED, 0);
			        int concurrent = url.getParameter(MonitorService.CONCURRENT, 0);
			        // init atomic reference
			        Statistics statistics = new Statistics(url);
			        	this.url = url;
				        this.application = url.getParameter(MonitorService.APPLICATION);
				        this.service = url.getParameter(MonitorService.INTERFACE);
				        this.method = url.getParameter(MonitorService.METHOD);
				        this.group = url.getParameter(MonitorService.GROUP);
				        this.version = url.getParameter(MonitorService.VERSION);
				        this.client = url.getParameter(MonitorService.CONSUMER, url.getAddress());
				        this.server = url.getParameter(MonitorService.PROVIDER, url.getAddress());
			        AtomicReference<long[]> reference = statisticsMap.computeIfAbsent(statistics, k -> new AtomicReference<>());
			        // use CompareAndSet to sum
			        long[] current;
			        long[] update = new long[LENGTH];
			        do {
			            current = reference.get();
			            if (current == null) {
			                update[0] = success;
			                update[1] = failure;
			                update[2] = input;
			                update[3] = output;
			                update[4] = elapsed;
			                update[5] = concurrent;
			                update[6] = input;
			                update[7] = output;
			                update[8] = elapsed;
			                update[9] = concurrent;
			            } else {
			                update[0] = current[0] + success;
			                update[1] = current[1] + failure;
			                update[2] = current[2] + input;
			                update[3] = current[3] + output;
			                update[4] = current[4] + elapsed;
			                update[5] = (current[5] + concurrent) / 2;
			                update[6] = current[6] > input ? current[6] : input;
			                update[7] = current[7] > output ? current[7] : output;
			                update[8] = current[8] > elapsed ? current[8] : elapsed;
			                update[9] = current[9] > concurrent ? current[9] : concurrent;
			            }
			        } while (!reference.compareAndSet(current, update));
        
        getConcurrent(invoker, invocation).decrementAndGet(); // count down
        	String key = invoker.getInterface().getName() + "." + invocation.getMethodName();
        	return concurrents.computeIfAbsent(key, k -> new AtomicInteger());
    }



TimeoutFilter onResponse
	Object obj = RpcContext.getContext().get(TIME_COUNTDOWN_KEY);
    if (obj != null) {
        TimeoutCountDown countDown = (TimeoutCountDown) obj;
        if (countDown.isExpired()) {
            ((AppResponse) appResponse).clear(); // clear response in case of timeout.
            if (logger.isWarnEnabled()) {
                logger.warn("invoke timed out. method: " + invocation.getMethodName() + " arguments: " +
                        Arrays.toString(invocation.getArguments()) + " , url is " + invoker.getUrl() +
                        ", invoke elapsed " + countDown.elapsedMillis() + " ms.");
            }
        }
    }

TraceFilter onResponse
	// .... 

GenericFilter onResponse
	// .... 

ClassLoaderFilter  没有  onResponse

ContextFilter onResponse 
	appResponse.addObjectAttachments(RpcContext.getServerContext().getObjectAttachments());





// methods = {@Method(name = "greeting", timeout = 9999999, retries = 1)}) 专门针对不同方法的超时时间是怎么处理的
// DubboInvoker # calculateTimeout方法，如果provider和consumer都配置了，那么以provider为准，如下

channel.getUrl().getParameters()
result = {Collections$UnmodifiableMap@4618}  size = 26

 "register.ip" -> "192.168.1.5"
 "heartbeat" -> "60000"
 "methods" -> "sayHello,sayGoodbye"
 "release" -> "release"
 "deprecated" -> "false"
 "dubbo" -> "2.0.2"
 "sayGoodbye.return" -> "true"
 "pid" -> "42635"
 "interface" -> "samples.annotation.api.HelloService"
 

 "timeout" -> "7777777" // 消费端的
 "sayGoodbye.timeout" -> "250" // 服务端的

 
 "remote.application" -> "samples-annotation-provider"
 "dynamic" -> "true"
 "anyhost" -> "true"
 "timestamp" -> "1621752346701"
 "init" -> "false"
 "side" -> "consumer"
 "check" -> "false"
 "version" -> "1.0.0_annotation"
 "generic" -> "false"
 "revision" -> "1.0.0_annotation"
 "codec" -> "dubbo"
 "metadata-type" -> "remote"
 "application" -> "samples-annotation-consumer"
 "sticky" -> "false"
 "sayGoodbye.retries" -> "0"

