
DubboBootstrapApplicationListener onApplicationContextEvent  // event 为 ContextStoppedEvent 不过没有相关分支进入

DubboLifecycleComponentApplicationListener onApplicationContextEvent  // event 为 ContextStoppedEvent 不过没有相关分支进入
	
再次上面两步骤，不过event为 ContextClosedEvent，同时发生异步操作

// 异步1 ====================================================================

DubboBootstrapApplicationListener onApplicationContextEvent

	onContextClosedEvent

	 	dubboBootstrap.stop();

	 		DubboBootstrap destroy();

DubboLifecycleComponentApplicationListener  onApplicationContextEvent

	onContextClosedEvent

		destroyLifecycleComponents 

			lifecycleComponents.forEach(Lifecycle::destroy);

// 异步2 ====================================================================
DubboShutdownHook 
	run
		ShutdownHookCallbacks # callback

			DubboBootstrap # destroy

				DubboShutdownHook.destroyAll();

					AbstractRegistryFactory.destroyAll()

			 			for (Registry registry : getRegistries()) 

			                registry.destroy();

			                	AbstractRegistry # destroy

			                		// unregister
			                		for (URL url : new HashSet<>(getRegistered())) {

					                	AbstractRegistry # unregister
					                		registered.remove(url);
					                	
					                	FailbackRegistry # unregister
											super.unregister(url);
											removeFailedRegistered(url);
											removeFailedUnregistered(url);
					                		doUnregister
					                			zkClient.delete(toUrlPath(url));
					                				toCategoryPath(url) + "/" + URL.encode(url.toFullString());
					                				// toCategoryPath  eg /dubbo/{path}/{category}  category为provider或者consumer

				                	// unsubscribe
				                	for (Map.Entry<URL, Set<NotifyListener>> entry : getSubscribed().entrySet()) {
				                		for (NotifyListener listener : entry.getValue())

						                	AbstractRegistry # unsubscribe(url, listener)
						                		subscribed.get(url).remove(listener)
						                		notified.remove(url);

						                	FailbackRegistry # unsubscribe(url, listener)
						                		super.unsubscribe(url, listener)
						                		removeFailedSubscribed(url, listener)

						                		doUnsubscribe // ZookeeperRegistry

						                			ChildListener zkListener = zkListeners.get(url).get(listener)

						                			for (String path : toCategoriesPath(url)) // providers、routers、configurators

						                				zkClient.removeChildListener(path, zkListener); // ChildListener

						                					AbstractZookeeperClient # removeChildListener

						                						CuratorWatcherImpl targetListener = childListeners.get(path).remove(listener)

						                						CuratorZookeeperClient # removeTargetChildListener(path, targetListener)

						                							CuratorWatcherImpl # unwatch

						                								childListener = null

						            // remove myself    			 	
						            AbstractRegistryFactory.removeDestroyedRegistry(this);
						            	lock.lock();
						            	REGISTRIES.entrySet().removeIf(entry -> entry.getValue().equals(toRm));


				                FailbackRegisty # destroy

				                	super.destroy();
        							retryTimer.stop();

        						ZookeeperRegistry

        							super.destroy();

						            zkClient.close();

						            	AbstractZookeeperClient # close

						            		closed = true

						            		CuratorZookeeperClient # doClose

						            				client.close();// CuratorFramework

						    registry.destroy(); // consumer端的还有一个ServiceDiscoverRegistry 

						    	AbstractRegistryFactory.removeDestroyedRegistry(this)

						    	serviceDiscovery.destroy()

						    		EventPublishingServiceDiscovery

						    			serviceDiscovery::destroy

						    				ZookeeperServiceDiscovery destroy

						    					curator.x.discovery.serviceDiscovery.close();

						REGISTRIES.clear()

					destroyProtocols();
						dubbo + inJvm + registry

						dubbo
							ProtocolFilterWrapper # destroy

								ProtocolListenerWrapper # destroy

									DubboProtocol destory

										// 1 provider 
										for (String key : new ArrayList<>(serverMap.keySet())) 

											 RemotingServer server = serverMap.remove(key).getRemotingServer();

											 	 server.close(ConfigurationUtils.getServerShutdownTimeout()); 

											 	  	HeaderExchangeServer close

											 	  		startClose 

											 	  			 server.startClose(); // server 为 nettyServer

											 	  			 	AbstractPeer startClose

											 	  			 		closing = true;

											 	  		sendChannelReadOnlyEvent();// 前提url含有"channel.readonly.send"

											 	  			new Request() + request.setEvent("R") 

											 	  			 Collection<Channel> channels = getChannels()
										 	  					getExchangeChannels()
										 	  						for (Channel channel : server.getChannels())
										 	  							HeaderExchangeChannel.getOrAddChannel(channel)

											 	  			for (Channel channel : channels)
											 	  				
											 	  				channel.send

											 	  				// ========================== 

											 	  				client端 HeaderExchangeHandler # received

											 	  					handlerEvent

											 	  						channel.setAttribute("channel.readonly", Boolean.TRUE);

											 	  		while (HeaderExchangeServer.this.isRunning()
											                    && System.currentTimeMillis() - start < max) {
											                    Thread.sleep(10);
											                isRunning
											                	Collection<Channel> channels = getChannels()
											                		for (Channel channel : channels)
											                			if (channel.isConnected()) 
											                				return true

											            HeaderExchangeServer # doClose()

											            	closed cas true  + closeTimerTask.cancel();

											            server.close - nettyServer

											            	AbstractServer close(int timeout) 

												            	ExecutorUtil.gracefulShutdown(executor, timeout);

												            		es.shutdown();

												            		if (!es.awaitTermination(timeout, TimeUnit.MILLISECONDS)) 
               															es.shutdownNow(); 

               														if (!isTerminated(es))
            															newThreadToCloseExecutor(es);

            																if (!isTerminated(es))
            																	run:
            																		for (int i = 0; i < 1000; i++)
            																			es.shutdownNow()
            																			if (es.awaitTermination(10
            																				break

	        													AbstractServer close()

	        														ExecutorUtil.shutdownNow(executor, 100);

	        														super.close(); // AbstractPeer
	        															closed = true;

	        														doClose()  // this 为 nettyServer 

	        															channel.close(); // unbind channel为netty.io

	        															for (Channel channel : getChannels()) 
	        																channel.close(); // channel 为 NettyChannel

	        															bossGroup.shutdownGracefully().syncUninterruptibly();

														                workerGroup.shutdownGracefully().syncUninterruptibly();

														                channels.clear(); // channel为NettyChannel


									    // 2 consumer
										for (String key : new ArrayList<>(referenceClientMap.keySet()))  // key为ip port

											for (ReferenceCountExchangeClient client : typedClients) 
												
												Object clients = referenceClientMap.remove(key)
												
												typedClients = (List<ReferenceCountExchangeClient>) clients

												for (ReferenceCountExchangeClient client : typedClients)

							                     closeReferenceCountExchangeClient(client);

							                     	// client 为 ReferenceCountExchangeClient
							                    	client.close(ConfigurationUtils.getServerShutdownTimeout()); 

							                    		referenceCount.decrementAndGet() <= 0

								                    		client.close(timeout);// client 为 HeaderExchangeClient

								                    			startClose();
								                    				channel.startClose // channel 为 HeaderExchangeChannel
								                    					channel.startClose // channel 为 NettyClient
								                    						AbstractPeer startClose
								                    							closing = true;

														        doClose();
														        	heartBeatTimerTask.close 
														        	reconnectTimerTask.close

														        channel.close(timeout); // channel为HeaderExchangeChannel
														        	
														        	closed=true

														        	if (timeout > 0) {
														        		while (DefaultFuture.hasFuture(channel)
													                    	&& System.currentTimeMillis() - start < timeout) {
													                    	Thread.sleep(10);

													                    	DefaultFuture # hasFuture 

													                    		CHANNELS.containsValue(channel)
													            	close()
													            		DefaultFuture.closeChannel(channel)

													            			for(CHANNELS.entrySet())

													            				DefaultFuture future = getFuture(entry.getKey())

													            				futureExecutor.shutdownNow()

													            				Response disconnectResponse = new Response

													            				DefaultFuture.received(channel, disconnectResponse)

													            					received(channel, response, false);

													            						DefaultFuture future = FUTURES.remove(response.getId());

													            						Timeout t = future.timeoutCheckTask;
													            						if (!timeout)
													            							t.cancel()

													            						future.doReceived(response)

													            							this.completeExceptionally(new RemotingException(channel, res.getErrorMessage()));

													            							if (threadlessExecutor.isWaiting())
													            								threadlessExecutor.notifyReturn


													            		channel.close() // NettyChannel

													            			super.close()
													            				closed = true

													            			removeChannelIfDisconnected(channel)

													            			attributes.clear()

													            			channel.close() // io.netty channel 
								                    	
								                    		replaceWithLazyClient();


								        // 3
								        super.destroy(); -- AbstractProtocol

								        	// consumer
								        	for (Invoker<?> invoker : invokers) 

								        		invoker = invokers.remove(invoker)

								        		invoker.destroy() //  DubboInvoker

								        			DubboInvoker destroyed

								        				double-check for super.isDestroyed()

								        				super.destroy();
								        					cas true + setAvailable(false) 

								        				invokers.remove(this)

								        				for (ExchangeClient client : clients)

								        					client.close(ConfigurationUtils.getServerShutdownTimeout());
								        					// 后面逻辑参考前面
								        				


								        	// provider
								        	for (String key : new ArrayList<String>(exporterMap.keySet())) 

												Exporter<?> exporter = exporterMap.remove(key); // DubboExporter

												exporter.unexport(); // AbstractExporter 

													unexported = true;

											        getInvoker().destroy();

											        	FilterNode destroy // filter = ContextFilter, invoker = InvokerDelegate

											        		invoker.destroy // invoker = RegistryProtocol#InvokerDelegate

											        			InvokerWrapper destroy

											        				DelegateProviderMetaDataInvoker destroy

											        					 invoker.destroy(); // JavassistProxyFactory$1

											        					 	AbstractProxyInvoker destroy

											        					 		// 空实现

											        afterUnExport();

											        	DubboExporter afterUnExport

											        		exporterMap.remove(key);

						injvm
							ProtocolFilterWrapper destroy

								ProtocolListenerWrapper # destroy

									InjvmProtocol destory // injvmProtocol 没有重写destory，所以直接AbstractProtocol # destroy 和上面dubboProtocol的最后大步骤一致

					    registry
					    	ProtocolFilterWrapper destroy

								ProtocolListenerWrapper destroy

									RegistryProtocol destroy // this 为 InterfaceCompatibleRegistryProtocol
										
										for (RegistryProtocolListener listener : listeners) 

                							listener.onDestroy();

                								MigrationRuleListener # onDestroy

                									configuration.removeListener(appName+".migration", "MIGRATION", this); 
                									// /dubbo/config/MIGRATION/samples-annotation-{provider/consumer}.migration 
                									// this 为 ConfigurationListener

                										CompositeDynamicConfiguration removeListener 

                											iterateListenerOperation
                												AbstractDynamicConfiguration removeListener
                													TreePathDynamicConfiguration removeListener

                														String pathKey = buildPathKey(group, key);

        																doRemoveListener(pathKey, listener)

        																	ZookeeperDynamicConfiguration doRemoveListener

        																			// cacheListener是DataListener的实现，内部有一个keyListeners
        																			zkClient.removeDataListener(pathKey, cacheListener)

        																				AbstractZookeeperClient	removeDataListener

        																					T targetListener = listeners.get(path).remove(listener);

        																					removeTargetDataListener(path, targetListener)	 

        																						CuratorZookeeperClient 	removeTargetDataListener

        																							nodeCacheMap.get(path).getListenable().removeListener(nodeCacheListener)
        																								nodeCacheListener.dataListener = null // NodeCacheListenerImpl

        																			cacheListener.removeListener(pathKey, listener)					



									    for (Exporter<?> exporter : new ArrayList<Exporter<?>>(bounds.values())) 
									            exporter.unexport();

									            	RegistryProtocol # ExporterChangeableWrapper # unexport

									            		bounds.remove(getCacheKey(this.originInvoker))

									            		registry.unregister(registerUrl) // DEFAULT_NOP_REGISTRY 空实现

									            		registry.unsubscribe(subscribeUrl, listener) // DEFAULT_NOP_REGISTRY 空实现

									            		GovernanceRuleRepository.removeListener
									            			dynamicConfiguration.removeListener(key, group, listener);
									            				// 后面链路参考前面
									            				// /dubbo/config/dubbo/samples.annotation.api.GreetingService:1.0.0_annotation.configurators

									            		exporter.unexport() 

									            			ListenerExporterWrapper unexport
									            				DubboExporter unexport
									            					AbstractExporter unexport
									            						if(unexported)
									            							return

									    bounds.clear();

									    GovernanceRuleRepository.removeListener

									    	// dubbo/config/duubosamples-annotation-{provider/consumer}.configurators

				unregisterServiceInstance();

					getServiceDiscoveries().forEach // AbstractRegistryFactory # getServiceDiscoveries

						serviceDiscovery.unregister(serviceInstance);

							EventPublishingServiceDiscovery unregister

								ZookeeperServiceDiscovery unregister

									curator.ServiceDiscovery # unregisterService(build(serviceInstance));

                unexportMetadataService();

                	metadataServiceExporter.unexport()

                		serviceConfig.unexport()

                unexportServices();

	                exportedServices.forEach(sc -> {

			            configManager.removeConfig(sc);
			            	configsCache.get(getTagName(config.getClass())) // tagName = "service"
			            		// id eg ServiceBean:samples.annotation.api.GreetingService:1.0.0_annotation
			            		configs.remove(getId(config)) 

			            sc.unexport(); // ServiceConfig

			            	if (!exported) 
			            		return 

			            	for (Exporter<?> exporter : exporters)

			            		exporter.unexport()

			            		injvm + DubboExporter

			            			// injvm
			            			ListenerExporterWrapper unexport
			            				InjvmExporter unexport
			            					AbstractExporter unexport
			            						if(unexported)
			            							return
			            			// DubboExporter
			            			DestroyableExporter unexport
			            				ExporterChangeableWrapper unexport	

			            	unexported = true;	

			            	dispatch(new ServiceConfigUnexportedEvent(this))		



			        });  // asyncExportingFutures 同理 

			        exportedServices.clear(); // asyncExportingFutures 同理 

                unreferServices();
                	cache.destroyAll() // ReferenceConfigCache

                destroyRegistries();

                	AbstractRegistryFactory.destroyAll();

                destroyServiceDiscoveries();

                	getServiceDiscoveries().forEach
			            execute(serviceDiscovery::destroy);

			        	EventPublishingServiceDiscovery destroy

			        		ZookeeperServiceDiscovery destroy

			        			curator.ServiceDiscovery # close

                destroyExecutorRepository();

                	DefaultExecutorRepository destroyAll

                		data.values().values() foreach

                			ExecutorUtil.shutdownNow(executor, 100);

                clear();
                	
                	clearConfigs();

                		configManager.destroy()

                			configsCache::clear
        			
        			clearApplicationModel();
        				// 空

                shutdown();

                	executorService.shutdown()

                release();

                	while (awaited.compareAndSet(false, true))
		                condition.signalAll();
		                
		        DubboBootstrapStartStopListener # onStop(DubboBootstrap bootstrap);

		        	applicationContext.publishEvent(new DubboBootstrapStopedEvent(bootstrap));

		doDestroy

			dispatch(new DubboServiceDestroyedEvent(this));

				eventDispatcher.dispatch(event);
