ReferenceBean#getObject返回的ref为
ref = {proxy0@4260} 
 handler = {InvokerInvocationHandler@4280} 
  invoker = {ServiceDiscoveryMigrationInvoker@4263} 
  consumerModel = {ConsumerModel@4281} 
  url = {URL@4282} "dubbo://30.25.58.158/samples.servicediscovery.demo.DemoService?application=demo-consumer&check=false&dubbo=2.0.2&init=false&interface=samples.servicediscovery.demo.DemoService&mapping-type=metadata&mapping.type=metadata&metadata-type=remote&methods=sayHello&pid=64096&provided-by=demo-provider&register.ip=30.25.58.158&side=consumer&sticky=false&timestamp=1620702737234"
  protocolServiceKey = "samples.servicediscovery.demo.DemoService:dubbo"


  
// ====================================================================

客户端发起rpc的正向流程

// ====================================================================


String hello = demoService.sayHello("world");

InvokerInvocationHandler invoke

	method.getDeclaringClass() == Object.class
		return method.invoke(invoker, args);

	toString、hashCode、$destroy、equals

	RpcInvocation rpcInvocation = new RpcInvocation(method, invoker.getInterface().getName(), protocolServiceKey, args);
	rpcInvocation.setTargetServiceUniqueName(invoker.getUrl().getServiceKey());
		invoker.getUrl
			MigrationInvoker getUrl
				if (invoker != null) {
            				invoker.getUrl();
            					MockClusterInvoker getUrl
            						directory.getConsumerUrl()
            							RegistryDirectory.getConsumerUrl
            								overrideDirectoryUrl;

	RpcContext.setRpcContext(invoker.getUrl());

		RpcContext.getContext().setConsumerUrl(url);
       
	invoker.invoke(rpcInvocation).recreate();

		if (!checkInvokerAvailable(serviceDiscoveryInvoker)) {

			invoker.invoke(invocation);

				MockClusterInvoker invoke

				.... // 同下

		if (!checkInvokerAvailable(invoker)) 

			ServiceDiscoveryMigrationInvoker invoke

				MockClusterInvoker invoke

					InterceptorInvokerNode invoke

						ConsumerContextClusterInterceptor before
							context.setInvocation(invocation).setLocalAddress(NetUtils.getLocalHost(), 0);
							((RpcInvocation) invocation).setInvoker(invoker);
							RpcContext.removeServerContext();

						ConsumerContextClusterInterceptor  intercept 

							ClusterInterceptor intercept // 接口的默认方法
							
								clusterInvoker.invoke(invocation);
								
									AbstractClusterInvoker invoke  // this为 FailoverClusterInvoker

										checkWhetherDestroyed();

										invocation.addObjectAttachments(RpcContext.getContext().getObjectAttachments());

										AbstractClusterInvoker list

											directory.list(invocation);

												AbstractDirectory list

													if (destroyed) 
														throw

													doList(invocation);

														// registry://
														RegistryDirectory doList

															if (forbidden) {
															if (multiGroup) {

															return invokers = routerChain.route(getConsumerUrl(), invocation);

																RouterChain route
														
														// sd://
														DynamicDirectory doList
															RouterChain route(mock、tag、service、app)
										initLoadBalance
											getExtension(invokers.get(0).getUrl().getMethodParameter("loadbalance"))

										RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);

										doInvoke(invocation, invokers, loadbalance);

											FailoverClusterInvoker doInvoke

											 	checkInvokers(copyInvokers, invocation);

											 	for (int i = 0; i < len; i++)

											 		Invoker<T> invoker = select(loadbalance, invocation, copyInvokers, invoked);

											 		 	AbstractClusterInvoker select

											 		 		doSelect(loadbalance, invocation, invokers, selected);

											 		RpcContext.getContext().setInvokers((List) invoked);

											 		Result result = invoker.invoke(invocation);

											 			RegistryDirectory InvokerDelegate invoke

											 				InvokerWrapper invoke
											 					FilterNode invoke 
											 						filter.invoke(next, invocation); // ConsumerContextFilter
											 							ConsumerContextFilter invoke
																			invoker.invoke(invocation);
																				FilterNode invoke 
																					filter.invoke(next, invocation);
																						FutureFilter invoke
																							MonitorFilter invoke
																								层次太深，另起开头

ListenerInvokerWrapper invoke

	AsyncToSyncInvoker invoke

		Result asyncResult = invoker.invoke(invocation);

			AbstractInvoker invoke // this为DubboInvoker

				invocation.setInvoker(this);
				invocation.addObjectAttachmentsIfAbsent(attachment);
				invocation.addObjectAttachments(contextAttachments);
				invocation.setInvokeMode(RpcUtils.getInvokeMode(url, invocation));
				RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);
				invocation.put(SERIALIZATION_ID_KEY, serializationId);

				(AsyncRpcResult) doInvoke(invocation);

					DubboInvoker doInvoke

						inv.setAttachment(PATH_KEY, getUrl().getPath());
						inv.setAttachment(VERSION_KEY, version);
						invocation.put(TIMEOUT_KEY, timeout);

						ExecutorService executor = getCallbackExecutor(getUrl(), inv);

							AbstractInvoker getCallbackExecutor

								InvokeMode.SYNC == RpcUtils.getInvokeMode(getUrl(), inv)

									ThreadlessExecutor(ExecutorService sharedExecutor) 

										this.sharedExecutor = sharedExecutor;

						CompletableFuture<AppResponse> appResponseFuture =
	                        currentClient.request(inv, timeout, executor).thenApply(obj -> (AppResponse) obj);

								ReferenceCountExchangeClient request

									client.request(request, timeout, executor);

										HeaderExchangeClient request

											channel.request(request, timeout, executor);

												HeaderExchangeChannel request

													Request req = new Request();
													req.setTwoWay(true);
													req.setData(request);// request为inv

													DefaultFuture.newFuture(channel, req, timeout, executor);
														
														new DefaultFuture(channel, request, timeout);

														future.setExecutor(executor);
														
														ThreadlessExecutor setWaitingFuture
															this.waitingFuture = waitingFuture;
														
														timeoutCheck
														
														return future;

													channel.send(req)

														AbstractPeer send //  this 为 NettyChannel

															send(message, url.getParameter(Constants.SENT_KEY, false));

																AbstractClient send

																	if (needReconnect && !isConnected())
															            connect();

															        Channel channel = getChannel();
															        	
															        	NettyClient getChannel
															        		
															        		NettyChannel.getOrAddChannel(channel, getUrl(), this);
															       
															        channel.send(message, sent);
															        	
															        	NettyChannel send 
															        	
															        	AbstractChannel send
																		
																		ChannelFuture future = channel.writeAndFlush(message);
																		
																		if (sent) 
																			success = future.await(timeout);
													return future;
							
							FutureContext.getContext().setCompatibleFuture(appResponseFuture);
			                
			                AsyncRpcResult result = new AsyncRpcResult(appResponseFuture, inv);
			                
			                result.setExecutor(executor);
			                	// 这里是ThreadlessExecutor
			                
			                return result;
			    
			    RpcContext.getContext().setFuture(new FutureAdapter(asyncResult.getResponseFuture()));
	        	return asyncResult;            

	    if (InvokeMode.SYNC == ((RpcInvocation) invocation).getInvokeMode()) 

	     	asyncResult.get(Integer.MAX_VALUE, TimeUnit.MILLISECONDS);

	     		if (executor != null && executor instanceof ThreadlessExecutor) {
            		ThreadlessExecutor threadlessExecutor = (ThreadlessExecutor) executor;
            		threadlessExecutor.waitAndDrain();

            			Runnable runnable = queue.take();

            				waiting = false;

            				runnable.run();

            					RunnableWrapper run

            						runnable.run();

            					// eg task1
            					ChannelEventRunnable run
            						
            						if (state == ChannelState.RECEIVED) 
            							
            							handler.received(channel, message);
            								
            								DecodeHandler received
            									
            									if (message instanceof Response)
            										
            										((Decodeable) message).decode();
            											
            											DecodeableRpcResult decode
            												 
            												 decode(channel, inputStream);
            												 	
            												 	handleValue(in);
            												 		
            												 		Type[] returnTypes = invocation.getReturnTypes();
            												 		
            												 		in.readObject((Class<?>) returnTypes[0], returnTypes[1])
            												 		
            												 		setValue(value); // Annotation, hello world
            												 			
            												 			AppResponse setValue // this 为DecodeableRpcResult
            												 				
            												 				this.result = value;
                												
                												handleAttachment(in);
                													
                													addObjectAttachments(in.readAttachments());

                								handler.received(channel, message);

                									HeaderExchangeHandler received

                										ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);
                										else if (message instanceof Response)
                											handleResponse(channel, (Response) message);
                												DefaultFuture.received(channel, response);
                													future.doReceived(response);
                														if (res.getStatus() == Response.OK) {
            																this.complete(res.getResult());
            														CHANNELS.remove(response.getId());

            					// eg task2
            					TimeoutCheckTask#run () -> notifyTimeout(future)

            						Response timeoutResponse = new Response(future.getId());
						            timeoutResponse.setStatus(future.isSent() ? SERVER_TIMEOUT : CLIENT_TIMEOUT);
						            timeoutResponse.setErrorMessage(future.getTimeoutMessage(true));

						            DefaultFuture.received(future.getChannel(), timeoutResponse, true);

            							 DefaultFuture.received(future.getChannel(), timeoutResponse, true);

            							 	DefaultFuture future = FUTURES.remove(response.getId());
            							 	Timeout t = future.timeoutCheckTask;
            							 	if (!timeout) 
            							 		t.cancel();
            							 	future.doReceived(response);

            							 		if (res.getStatus() == Response.OK) {
										            this.complete(res.getResult());
										        } else if (res.getStatus() == Response.CLIENT_TIMEOUT || res.getStatus() == Response.SERVER_TIMEOUT) {
										            this.completeExceptionally(new TimeoutException(res.getStatus() == Response.SERVER_TIMEOUT, channel, res.getErrorMessage()));
										        } else {
										            this.completeExceptionally(new RemotingException(channel, res.getErrorMessage()));
										        }

										        if (threadlessExecutor.isWaiting()) {
               										threadlessExecutor.notifyReturn
            			
        				runnable = queue.poll();
        				while (runnable != null) {
				            runnable.run();
				            runnable = queue.poll();
				        }

				        finished = true;

				    return responseFuture.get(timeout, unit);

        return asyncResult;

        // ====================================================================
        // 另起行结果回流流程如下
        // ====================================================================

ListenerInvokerWrapper invoke
	return invoker.invoke(invocation);

Moniter invoke
	return invoker.invoke(invocation);

FutureFilter invoke
	return invoker.invoke(invocation);

ConsumerContextFilter invoke
	return invoker.invoke(invocation);

InvokerWrapper invoke
	return invoker.invoke(invocation);

FailoverClusterInvoker doInvoke
	Result result = invoker.invoke(invocation);
	return result;

AbstractClusterInvoker invoke
	return doInvoke(invocation, invokers, loadbalance);

ClusterInterceptor intercept
	return clusterInvoker.invoke(invocation);

InterceptorInvokerNode invoke
	asyncResult = interceptor.intercept(next, invocation);
	interceptor.after(next, invocation);
		ConsumerContextClusterInterceptor after
			RpcContext.removeContext(true);
				LOCAL.remove();
	asyncResult.whenCompleteWithContext((r, t) -> {
		listener.onMessage(r, clusterInvoker, invocation);
			 RpcContext.getServerContext().setObjectAttachments(appResponse.getObjectAttachments());

MockClusterInvoker invoke
	result = this.invoker.invoke(invocation);
	return result;

MigrationInvoker invoke
	return invoker.invoke(invocation);

InvokerInvocationHandler invoke
	return invoker.invoke(rpcInvocation).recreate();
		AsyncRpcResult recreate
			 getAppResponse().recreate();
			 	if (exception != null) {
			 		// .....
		            throw exception;
		        }
		        return result;

AnnotationAction doSayHello
	return helloService.sayHello(name);

AnnotationConsumerBootstrap main
	System.out.println("hello : " + annotationAction.doSayHello("world"));


// ====================================================================

客户端接收响应包

// ====================================================================


NettyCodecAdapter # InternalDecoder

	InternalDecoder decode(ChannelHandlerContext ctx, ByteBuf input, List<Object> out)

		ChannelBuffer message = new NettyBackedChannelBuffer(input);

			NettyBackedChannelBuffer(ByteBuf buffer)

				this.buffer = buffer;

        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);

        	NettyChannel ret = CHANNEL_MAP.get(ch); // double-check

        do {
            int saveReaderIndex = message.readerIndex();
            Object msg = codec.decode(channel, message);
            if (msg == Codec2.DecodeResult.NEED_MORE_INPUT) {
                message.readerIndex(saveReaderIndex);
                break;
            } else {
                //is it possible to go here ?
                if (saveReaderIndex == message.readerIndex()) {
                    throw new IOException("Decode without read data.");
                }
                if (msg != null) {
                    out.add(msg);
                }
            }
        } while (message.readable());

DubboCountCodec decode

ExchangdeCodec decode

DubboCodec decodeBody

NettyClientHandler channelRead

AbstractPeer received

MultiMessageHandler received

HeartbeatHandler received

AllChannelHandler received
	DefaultFuture getFuture
	executor = ThreadlessExecutor
		RunnableWrapper

asyncResult.get(Integer.MAX_VALUE, TimeUnit.MILLISECONDS);

下面是异步写server并从server角度处理和回传响应
// ====================================================================
	NettyClientHandler write

	InternalEncoder encode

	DubboCountCodec encode

	ExchangeCodec encode

	DubboCodec encodeRequestData 


	// server
	InternalDecoder decode

	DubboCountCodec decode

	ExchangeCodec decode

	DubboCodec decodeBody

	NettyServerHandler channelRead

	AbstractPeer received

	MultiMessageHandler received

	HeartbeatHandler received

	AllChannelHandler received

	DecodeHandler received
		DecodeHandler decode

		DecodeableRpcInvocation decode

	HeaderExchangeHandler received
 
	requestHandler received

	FilterNode invoke
		ContextFilter invoke

	FilterNode invoke
		EchoFilter	invoke

	FilterNode invoke
		ClassLoaderFilter	invoke

	FilterNode invoke
		GenericFilter	invoke
		.... 
		TraceFilter
		TimeoutFilter
		MoniterFilter
		ExceptionFilter
	InvokerWrapper invoke - this 为 InvokerDelegate

	DelegateProviderMetaDataInvoker invoke	

	AbstractProxyInvoker invoke - this 为javassist生成的 注意 proxy 为DemoServiceImpl

	JavassistProxyFactory$1 doInvoke

	ExceptionFilter onResponse
	TimeoutFilter onResponse
	MoniterFilter onResponse

	TraceFilter invoke
	GenericFilter onResponse
	ClassLoaderFilter invoke
	ContextFilter onResponse

	requestHandler reply


	HeaderExchangeHandler handleRequest

	HeaderExchangeChannel send

	NettyChannel send

	channel.writeAndFlush(message);

// todo 需要debug跟踪的 ====================================================================
TimeoutCheckTask

// todo need pr ====================================================================
ConsumerContextClusterInterceptor 
 RpcContext context = RpcContext.getContext();
        context.setInvocation(invocation).setLocalAddress(NetUtils.getLocalHost(), 0);
        可以删除这部分，因为和ConsumerContextFilter重复了


 AbstractInvoker       invocation.setInvoker(this);  和  ConsumerContextFilter 重复






