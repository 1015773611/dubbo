ReferenceBean#getObject返回的ref为
ref = {proxy0@4260} 
 handler = {InvokerInvocationHandler@4280} 
  invoker = {ServiceDiscoveryMigrationInvoker@4263} 
  consumerModel = {ConsumerModel@4281} 
  url = {URL@4282} "dubbo://30.25.58.158/samples.servicediscovery.demo.DemoService?application=demo-consumer&check=false&dubbo=2.0.2&init=false&interface=samples.servicediscovery.demo.DemoService&mapping-type=metadata&mapping.type=metadata&metadata-type=remote&methods=sayHello&pid=64096&provided-by=demo-provider&register.ip=30.25.58.158&side=consumer&sticky=false&timestamp=1620702737234"
  protocolServiceKey = "samples.servicediscovery.demo.DemoService:dubbo"


  
// ====================================================================
// ====================================================================

客户端发起rpc的正向流程

// ====================================================================
// ====================================================================


String hello = demoService.sayHello("world");

InvokerInvocationHandler invoke

	method.getDeclaringClass() == Object.class
		return method.invoke(invoker, args);

	toString、hashCode、$destroy、equals

	RpcInvocation rpcInvocation = new RpcInvocation(method, invoker.getInterface().getName(), protocolServiceKey, args);
	rpcInvocation.setTargetServiceUniqueName(invoker.getUrl().getServiceKey());
		invoker.getUrl
			MigrationInvoker getUrl
				if (invoker != null) {
            				invoker.getUrl();
            					MockClusterInvoker getUrl
            						directory.getConsumerUrl()
            							RegistryDirectory.getConsumerUrl
            								overrideDirectoryUrl;

	RpcContext.setRpcContext(invoker.getUrl());

		RpcContext.getContext().setConsumerUrl(url);
       
	invoker.invoke(rpcInvocation).recreate();

		if (!checkInvokerAvailable(serviceDiscoveryInvoker)) {

			invoker.invoke(invocation);

				MockClusterInvoker invoke

				.... // 同下

		if (!checkInvokerAvailable(invoker)) 

			ServiceDiscoveryMigrationInvoker invoke

				MockClusterInvoker invoke

					InterceptorInvokerNode invoke

						ConsumerContextClusterInterceptor before
							context.setInvocation(invocation).setLocalAddress(NetUtils.getLocalHost(), 0);
							((RpcInvocation) invocation).setInvoker(invoker);
							RpcContext.removeServerContext();

						ConsumerContextClusterInterceptor  intercept 

							ClusterInterceptor intercept // 接口的默认方法
							
								clusterInvoker.invoke(invocation);
								
									AbstractClusterInvoker invoke  // this为 FailoverClusterInvoker

										checkWhetherDestroyed();

										invocation.addObjectAttachments(RpcContext.getContext().getObjectAttachments());

										AbstractClusterInvoker list

											directory.list(invocation);

												AbstractDirectory list

													if (destroyed) 
														throw

													doList(invocation);

														// registry://
														RegistryDirectory doList

															if (forbidden) {
															if (multiGroup) {

															return invokers = routerChain.route(getConsumerUrl(), invocation);

																RouterChain route
														
														// sd://
														DynamicDirectory doList
															RouterChain route(mock、tag、service、app)
										initLoadBalance
											getExtension(invokers.get(0).getUrl().getMethodParameter("loadbalance"))

										RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);

										doInvoke(invocation, invokers, loadbalance);

											FailoverClusterInvoker doInvoke

											 	checkInvokers(copyInvokers, invocation);

											 	for (int i = 0; i < len; i++)

											 		Invoker<T> invoker = select(loadbalance, invocation, copyInvokers, invoked);

											 		 	AbstractClusterInvoker select

											 		 		doSelect(loadbalance, invocation, invokers, selected);

											 		RpcContext.getContext().setInvokers((List) invoked);

											 		Result result = invoker.invoke(invocation);

											 			RegistryDirectory InvokerDelegate invoke

											 				InvokerWrapper invoke
											 					FilterNode invoke 
											 						filter.invoke(next, invocation); // ConsumerContextFilter
											 							ConsumerContextFilter invoke
																			invoker.invoke(invocation);
																				FilterNode invoke 
																					filter.invoke(next, invocation);
																						FutureFilter invoke
																							MonitorFilter invoke
																								层次太深，另起开头

ListenerInvokerWrapper invoke

	AsyncToSyncInvoker invoke

		Result asyncResult = invoker.invoke(invocation);

			AbstractInvoker invoke // this为DubboInvoker

				invocation.setInvoker(this);
				invocation.addObjectAttachmentsIfAbsent(attachment);
				invocation.addObjectAttachments(contextAttachments);
				invocation.setInvokeMode(RpcUtils.getInvokeMode(url, invocation));
				RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);
				invocation.put(SERIALIZATION_ID_KEY, serializationId);

				(AsyncRpcResult) doInvoke(invocation);

					DubboInvoker doInvoke

						inv.setAttachment(PATH_KEY, getUrl().getPath());
						inv.setAttachment(VERSION_KEY, version);
						invocation.put(TIMEOUT_KEY, timeout);

						ExecutorService executor = getCallbackExecutor(getUrl(), inv);

							AbstractInvoker getCallbackExecutor

								InvokeMode.SYNC == RpcUtils.getInvokeMode(getUrl(), inv)

									ThreadlessExecutor(ExecutorService sharedExecutor) 

										this.sharedExecutor = sharedExecutor;

						CompletableFuture<AppResponse> appResponseFuture =
	                        currentClient.request(inv, timeout, executor).thenApply(obj -> (AppResponse) obj);

								ReferenceCountExchangeClient request

									client.request(request, timeout, executor);

										HeaderExchangeClient request

											channel.request(request, timeout, executor);

												HeaderExchangeChannel request

													Request req = new Request();
													req.setTwoWay(true);
													req.setData(request);// request为inv

													DefaultFuture.newFuture(channel, req, timeout, executor);
														
														new DefaultFuture(channel, request, timeout);

														future.setExecutor(executor);
														
														ThreadlessExecutor setWaitingFuture
															this.waitingFuture = waitingFuture;
														
														timeoutCheck
														
														return future;

													channel.send(req)

														AbstractPeer send //  this 为 NettyChannel

															send(message, url.getParameter(Constants.SENT_KEY, false));

																AbstractClient send

																	if (needReconnect && !isConnected())
															            connect();

															        Channel channel = getChannel();
															        	
															        	NettyClient getChannel
															        		
															        		NettyChannel.getOrAddChannel(channel, getUrl(), this);
															       
															        channel.send(message, sent);
															        	
															        	NettyChannel send 
															        	
															        	AbstractChannel send
																		
																		ChannelFuture future = channel.writeAndFlush(message);
																		
																		if (sent) 
																			success = future.await(timeout);
													return future;
							
							FutureContext.getContext().setCompatibleFuture(appResponseFuture);
			                
			                AsyncRpcResult result = new AsyncRpcResult(appResponseFuture, inv);
			                
			                result.setExecutor(executor);
			                	// 这里是ThreadlessExecutor
			                
			                return result;
			    
			    RpcContext.getContext().setFuture(new FutureAdapter(asyncResult.getResponseFuture()));
	        	return asyncResult;            

	    if (InvokeMode.SYNC == ((RpcInvocation) invocation).getInvokeMode()) 

	     	asyncResult.get(Integer.MAX_VALUE, TimeUnit.MILLISECONDS);

	     		if (executor != null && executor instanceof ThreadlessExecutor) {
            		ThreadlessExecutor threadlessExecutor = (ThreadlessExecutor) executor;
            		threadlessExecutor.waitAndDrain();

            			Runnable runnable = queue.take();

            				waiting = false;

            				runnable.run();

            					RunnableWrapper run

            						runnable.run();

            					// eg task1
            					ChannelEventRunnable run
            						
            						if (state == ChannelState.RECEIVED) 
            							
            							handler.received(channel, message);
            								
            								DecodeHandler received
            									
            									if (message instanceof Response)
            										
            										((Decodeable) message).decode();
            											
            											DecodeableRpcResult decode
            												 
            												 decode(channel, inputStream);
            												 	
            												 	handleValue(in);
            												 		
            												 		Type[] returnTypes = invocation.getReturnTypes();
            												 		
            												 		in.readObject((Class<?>) returnTypes[0], returnTypes[1])
            												 		
            												 		setValue(value); // Annotation, hello world
            												 			
            												 			AppResponse setValue // this 为DecodeableRpcResult
            												 				
            												 				this.result = value;
                												
                												handleAttachment(in);
                													
                													addObjectAttachments(in.readAttachments());

                								handler.received(channel, message);

                									HeaderExchangeHandler received

                										ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);
                										else if (message instanceof Response)
                											handleResponse(channel, (Response) message);
                												DefaultFuture.received(channel, response);
                													future.doReceived(response);
                														if (res.getStatus() == Response.OK) {
            																this.complete(res.getResult());
            														CHANNELS.remove(response.getId());

            					// eg task2
            					TimeoutCheckTask#run () -> notifyTimeout(future)

            						Response timeoutResponse = new Response(future.getId());
						            timeoutResponse.setStatus(future.isSent() ? SERVER_TIMEOUT : CLIENT_TIMEOUT);
						            timeoutResponse.setErrorMessage(future.getTimeoutMessage(true));

						            DefaultFuture.received(future.getChannel(), timeoutResponse, true);

            							 DefaultFuture.received(future.getChannel(), timeoutResponse, true);

            							 	DefaultFuture future = FUTURES.remove(response.getId());
            							 	Timeout t = future.timeoutCheckTask;
            							 	if (!timeout) 
            							 		t.cancel();
            							 	future.doReceived(response);

            							 		if (res.getStatus() == Response.OK) {
										            this.complete(res.getResult());
										        } else if (res.getStatus() == Response.CLIENT_TIMEOUT || res.getStatus() == Response.SERVER_TIMEOUT) {
										            this.completeExceptionally(new TimeoutException(res.getStatus() == Response.SERVER_TIMEOUT, channel, res.getErrorMessage()));
										        } else {
										            this.completeExceptionally(new RemotingException(channel, res.getErrorMessage()));
										        }

										        if (threadlessExecutor.isWaiting()) {
               										threadlessExecutor.notifyReturn
            			
        				runnable = queue.poll();
        				while (runnable != null) {
				            runnable.run();
				            runnable = queue.poll();
				        }

				        finished = true;

				    return responseFuture.get(timeout, unit);

        return asyncResult;

        // ====================================================================
        // 另起行结果回流流程如下
        // ====================================================================

ListenerInvokerWrapper invoke
	return invoker.invoke(invocation);

Moniter invoke
	return invoker.invoke(invocation);

FutureFilter invoke
	return invoker.invoke(invocation);

ConsumerContextFilter invoke
	return invoker.invoke(invocation);

InvokerWrapper invoke
	return invoker.invoke(invocation);

FailoverClusterInvoker doInvoke
	Result result = invoker.invoke(invocation);
	return result;

AbstractClusterInvoker invoke
	return doInvoke(invocation, invokers, loadbalance);

ClusterInterceptor intercept
	return clusterInvoker.invoke(invocation);

InterceptorInvokerNode invoke
	asyncResult = interceptor.intercept(next, invocation);
	interceptor.after(next, invocation);
		ConsumerContextClusterInterceptor after
			RpcContext.removeContext(true);
				LOCAL.remove();
	asyncResult.whenCompleteWithContext((r, t) -> {
		listener.onMessage(r, clusterInvoker, invocation);
			 RpcContext.getServerContext().setObjectAttachments(appResponse.getObjectAttachments());

MockClusterInvoker invoke
	result = this.invoker.invoke(invocation);
	return result;

MigrationInvoker invoke
	return invoker.invoke(invocation);

InvokerInvocationHandler invoke
	return invoker.invoke(rpcInvocation).recreate();
		AsyncRpcResult recreate
			 getAppResponse().recreate();
			 	if (exception != null) {
			 		// .....
		            throw exception;
		        }
		        return result;

AnnotationAction doSayHello
	return helloService.sayHello(name);

AnnotationConsumerBootstrap main
	System.out.println("hello : " + annotationAction.doSayHello("world"));


// ====================================================================
// ====================================================================

客户端接收响应包

// ====================================================================
// ====================================================================


NettyCodecAdapter # InternalDecoder

	InternalDecoder decode(ChannelHandlerContext ctx, ByteBuf input, List<Object> out)

		ChannelBuffer message = new NettyBackedChannelBuffer(input);
			NettyBackedChannelBuffer(ByteBuf buffer)
				this.buffer = buffer;

        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);
        	NettyChannel ret = CHANNEL_MAP.get(ch); // double-check

        do {
            int saveReaderIndex = message.readerIndex();
            	buffer.readerIndex(); // ByteBuf buffer

            Object msg = codec.decode(channel, message);
            	//	另起新开头行

            if (msg == Codec2.DecodeResult.NEED_MORE_INPUT) {
                message.readerIndex(saveReaderIndex);
                break;
            } else {
                //is it possible to go here ?
                if (saveReaderIndex == message.readerIndex()) {
                    throw new IOException("Decode without read data.");
                }
                if (msg != null) {
                    out.add(msg);
                }
            }
        } while (message.readable());

// ====================================================================
DubboCountCodec decode
	
	int save = buffer.readerIndex();

    MultiMessage result = MultiMessage.create();
    	new MultiMessage();
    		private final List messages = new ArrayList();
    
    do {
        Object obj = codec.decode(channel, buffer);
        	//	另起新开头行
        
        if (Codec2.DecodeResult.NEED_MORE_INPUT == obj) {
            buffer.readerIndex(save);
            break;
        } else {

            result.addMessage(obj);
            	
            	messages.add(msg);

            logMessageLength(obj, buffer.readerIndex() - save);
            	
            	else if (result instanceof Response)
            		
            		((AppResponse) ((Response) result).getResult()).setAttachment(OUTPUT_KEY, String.valueOf(bytes));
            		// output -> 55
            
            save = buffer.readerIndex();
        }
    } while (true);

    if (result.isEmpty()) {
        return Codec2.DecodeResult.NEED_MORE_INPUT;
    }

    if (result.size() == 1) {
        return result.get(0);
    }
    return result;

// ====================================================================

ExchangdeCodec decode(Channel channel, ChannelBuffer buffer)
	
	int readable = buffer.readableBytes();
    
    byte[] header = new byte[Math.min(readable, HEADER_LENGTH)];
    
    buffer.readBytes(header);
    	NettyBackedChannelBuffer readBytes
    		buffer.readBytes(dst); // ByteBuf
    
    return decode(channel, buffer, readable, header);

    ExchangdeCodec decode
    	
    	if (readable < HEADER_LENGTH) {
            return DecodeResult.NEED_MORE_INPUT;
        }

        int len = Bytes.bytes2int(header, 12);
        	
        	return ((b[off + 3] & 0xFF) << 0) +
                ((b[off + 2] & 0xFF) << 8) +
                ((b[off + 1] & 0xFF) << 16) +
                ((b[off + 0]) << 24);
        
        finishRespWhenOverPayload

        checkPayload(channel, len);

        int tt = len + HEADER_LENGTH;
        if (readable < tt) {
            return DecodeResult.NEED_MORE_INPUT;
        }

        ChannelBufferInputStream is = new ChannelBufferInputStream(buffer, len);
	        this.buffer = buffer;
	        startIndex = buffer.readerIndex();
	        endIndex = startIndex + length;
	        buffer.markReaderIndex();

	    return decodeBody(channel, is, header); // this为DubboCodec，进去看DubboCodec重写的 decodeBody 方法

	    	// decodeBody整体逻辑非常复杂，粘贴解析response的部分小部分，具体看源代码
	    	
	    	Response res = new Response(id);

	    	DecodeableRpcResult result = new DecodeableRpcResult(channel, res,
                                    new UnsafeByteArrayInputStream(readMessageData(is)),
                                    (Invocation) getRequestData(id), proto);
                
                readMessageData(InputStream is)
                	
                	if (is.available() > 0) {
                		
                		ChannelBufferInputStream available
                			
                			return endIndex - buffer.readerIndex();
                	
                	byte[] result = new byte[is.available()];
		            
		            is.read(result);
		            	
		            	ChannelBufferInputStream read(byte[] b, int off, int len)
			            	
			            	int available = available();
					        
					        if (available == 0) {
					            return -1;
					        }
					        
					        len = Math.min(available, len);
					        
					        buffer.readBytes(b, off, len);
					        	
					        	NettyBackedChannelBuffer readBytes(byte[] dst, int dstIndex, int length)
					        		
					        		buffer.readBytes(dst, dstIndex, length); // byteBuf
					        
					        return len;
		            
		            return result;

		        UnsafeByteArrayInputStream
		        	this(buf, 0, buf.length);
			        	mData = buf;
	        			mPosition = mMark = offset;
	       				mLimit = Math.min(offset + length, buf.length);

            res.setResult(data);

NettyClientHandler channelRead

	AbstractPeer received // this为NettyClient

		handler.received(ch, msg); 

			MultiMessageHandler received

				if (message instanceof MultiMessage) {
		            MultiMessage list = (MultiMessage) message;
		            for (Object obj : list) {
		                handler.received(channel, obj);
		            }
		        } else {
		            handler.received(channel, message);

		            	HeartbeatHandler received

		            		setReadTimestamp(channel);

		            		if (isHeartbeatRequest(message)) {

		            		if (isHeartbeatResponse(message)) {

		            			handler.received(channel, message);

		            				AllChannelHandler received

		            					ExecutorService executor = getPreferredExecutorService(message);

		            						WrappedChannelHandler getPreferredExecutorService

		            							if (msg instanceof Response) {
										            Response response = (Response) msg;
										            DefaultFuture responseFuture = DefaultFuture.getFuture(response.getId());
										            if (responseFuture == null) {
										                return getSharedExecutorService();
										            } else {
										                ExecutorService executor = responseFuture.getExecutor();
										                if (executor == null || executor.isShutdown()) {
										                    executor = getSharedExecutorService();
										                }
										                // ThreadlessExecutor
										                return executor;
										            }
										        } else {
										        	return getSharedExecutorService();
										        }

		            					executor.execute(new ChannelEventRunnable(channel, handler, RECEIVED, message));

		            						ThreadlessExecutor execute(Runnable runnable)

		            							runnable = new RunnableWrapper(runnable);

		            							synchronized (lock) {

		            							 	queue.add(runnable);

		            							 	// 后续过程在前面讲到了就是AsyncToSync的result.get()操作

// ====================================================================
// ====================================================================

下面是client写server 

// ====================================================================
// ====================================================================

NettyClientHandler write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)

	super.write(ctx, msg, promise);
	// 另起新开头行

	final NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);
    
    final boolean isRequest = msg instanceof Request;
    
    promise.addListener(future -> {
        
        if (future.isSuccess()) {
            
            handler.sent(channel, msg);

            	AbstractPeer sent(Channel ch, Object msg) // this 为NettyClient
            		
            		if (closed) 
            			return;
            		
            		handler.sent(ch, msg); // handler 为MultiMessageHandler
            			
            			AbstractChannelHandlerDelegate	sent // this为MultiMessageHandler
            				
            				handler.sent(channel, message); // handler 为 HeartbeatHandler
            					
            					setWriteTimestamp(channel);
            						channel.setAttribute(KEY_WRITE_TIMESTAMP, System.currentTimeMillis());
            							NettyChannel setAttribute(String key, Object value)
            								attributes.put(key, value);
        						
        						handler.sent(channel, message); // handler为DecodeHandler
        							
        							AbstractChannelHandlerDelegate	sent
        							 	
        							 	handler.sent(channel, message); // handler为HeaderExchangeHandler
        							 		
        							 		HeaderExchangeHandler sent(Channel channel, Object message) 
	        							 		
	        							 		ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);
									            
									            handler.sent(exchangeChannel, message); // handler为requestHandler
									            	ChannelHandlerAdapter sent
									            		// 空
									            
									            if (message instanceof Request) {
										            
										            Request request = (Request) message;
										            
										            DefaultFuture.sent(channel, request);	
										            	
										            	FUTURES.get(request.getId()).doSent();
										            		
										            		DefaultFuture doSent
										            			
										            			sent = System.currentTimeMillis();
										            			
										            			// 记录sent是为了区分是客户端超时还是服务端超时
										            			// 注意getTimeoutMessage方法的调用点 和 isSent 方法

        }

        Throwable t = future.cause();
        if (t != null && isRequest) {
            Request request = (Request) msg;
            Response response = buildErrorResponse(request, t);
            handler.received(channel, response);
        }
    });

InternalEncoder encode(ChannelHandlerContext ctx, Object msg, ByteBuf out)

	ChannelBuffer buffer = new NettyBackedChannelBuffer(out);
		NettyBackedChannelBuffer(ByteBuf buffer)
			this.buffer = buffer;
	
	NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);
	
	codec.encode(channel, buffer, msg);

		DubboCountCodec encode 

			codec.encode(channel, buffer, msg);

				ExchangeCodec encode

					if (msg instanceof Request) 
            			
            			encodeRequest(channel, buffer, (Request) msg);

            				Serialization serialization = getSerialization(channel, req);

            				byte[] header = new byte[HEADER_LENGTH];
					        
					        Bytes.short2bytes(MAGIC, header);
					        	b[off + 1] = (byte) v;
        						b[off + 0] = (byte) (v >>> 8);

					        header[2] = (byte) (FLAG_REQUEST | serialization.getContentTypeId());
					        
					        if (req.isTwoWay()) {
					            header[2] |= FLAG_TWOWAY;
					        }
					        
					        if (req.isEvent()) {
					            header[2] |= FLAG_EVENT;
					        }

					        Bytes.long2bytes(req.getId(), header, 4);
					        	
					        	Bytes long2bytes(long v, byte[] b, int off)
						        	
						        	b[off + 7] = (byte) v;
							        b[off + 6] = (byte) (v >>> 8);
							        b[off + 5] = (byte) (v >>> 16);
							        b[off + 4] = (byte) (v >>> 24);
							        b[off + 3] = (byte) (v >>> 32);
							        b[off + 2] = (byte) (v >>> 40);
							        b[off + 1] = (byte) (v >>> 48);
							        b[off + 0] = (byte) (v >>> 56);

					        // encode request data.
					        int savedWriteIndex = buffer.writerIndex();
					        	return buffer.writerIndex();

					        buffer.writerIndex(savedWriteIndex + HEADER_LENGTH);
					        	buffer.writerIndex(writerIndex);
					       
					        ChannelBufferOutputStream bos = new ChannelBufferOutputStream(buffer);
					        	ChannelBufferOutputStream(ChannelBuffer buffer)
					        		this.buffer = buffer;
        							startIndex = buffer.writerIndex();

        					if (req.isHeartbeat()) {
        					else
        						ObjectOutput out = serialization.serialize(channel.getUrl(), bos);
        							Hessian2Serialization serialize(URL url, OutputStream out)
        								return new Hessian2ObjectOutput(out);
        									mH2o = OUTPUT_TL.get();
        									mH2o.init(os);
	        					if (req.isEvent()) {
	        						// .....
					            } else {
					                encodeRequestData(channel, out, req.getData(), req.getVersion());
					                // 另起开头，走 DubboCodec
					            }

					            out.flushBuffer();
					            	 mH2o.flushBuffer();
					           	
					           	if (out instanceof Cleanable) {
	                				((Cleanable) out).cleanup();
	                					Hessian2ObjectOutput cleanup
	                						mH2o.reset();

                			bos.flush();
					        bos.close();
					        int len = bos.writtenBytes();
					        	 return buffer.writerIndex() - startIndex;
					        checkPayload(channel, len);
					        Bytes.int2bytes(len, header, 12);
					        	Bytes public static void int2bytes(int v, byte[] b, int off) {
							        b[off + 3] = (byte) v;
							        b[off + 2] = (byte) (v >>> 8);
							        b[off + 1] = (byte) (v >>> 16);
							        b[off + 0] = (byte) (v >>> 24);
							    }

					        // write
					        buffer.writerIndex(savedWriteIndex);
					        buffer.writeBytes(header); // write header.
						        NettyBackedChannelBuffer writeBytes(byte[] src)
						        	buffer.writeBytes(src);
					        buffer.writerIndex(savedWriteIndex + HEADER_LENGTH + len);

// ====================================================================
DubboCodec encodeRequestData(Channel channel, ObjectOutput out, Object data, String version) 
	RpcInvocation inv = (RpcInvocation) data;

    out.writeUTF(version);
    	Hessian2ObjectOutput writeUTF(String v)
    		mH2o.writeString(v);
    
    String serviceName = inv.getAttachment(INTERFACE_KEY);
    	Object value = attachments.get(key);
    	if (value instanceof String) {
            return (String) value;
   
    if (serviceName == null) {
        serviceName = inv.getAttachment(PATH_KEY);
    }
    
    out.writeUTF(serviceName);
    out.writeUTF(inv.getAttachment(VERSION_KEY));

    out.writeUTF(inv.getMethodName());
    out.writeUTF(inv.getParameterTypesDesc());
    Object[] args = inv.getArguments();
    if (args != null) {
        for (int i = 0; i < args.length; i++) {
            out.writeObject(encodeInvocationArgument(channel, inv, i));
            	Hessian2ObjectOutput writeObject(Object obj)
            		mH2o.writeObject(obj);
        }
    }
    out.writeAttachments(inv.getObjectAttachments());
    	Hessian2ObjectOutput writeAttachments(Map<String, Object> attachments)
    		writeObject(attachments);

// ====================================================================
// ====================================================================
	server接受client请求并回传响应
// ====================================================================
// ====================================================================

InternalDecoder decode // 参考前面 client 接受 server 响应的过程
	

DubboCountCodec decode // 参考前面 client 接受 server 响应的过程

ExchangeCodec decode // 参考前面 client 接受 server 响应的过程

DubboCodec decodeBody // 参考前面 client 接受 server 响应的过程

NettyServerHandler channelRead

	NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);
    
    handler.received(channel, msg); // handler为NettyServer
    	
    	AbstractPeer received
    		if (closed) {
            	return;
            
            handler.received(ch, msg);

				MultiMessageHandler received

					HeartbeatHandler received
						setReadTimestamp(channel);

						AllChannelHandler received
							ExecutorService executor = getPreferredExecutorService(message);
								WrappedChannelHandler getPreferredExecutorService
									if (msg instanceof Response) {
									else {
	            						return getSharedExecutorService();
	            							executorRepository.getExecutor(url);
	            								DefaultExecutorRepository getExecutor
	            									return data.get(EXECUTOR_SERVICE_COMPONENT_KEY).get(portKey);
							
							executor.execute(new ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message));
							// 另起一行

DecodeHandler received
	
	if (message instanceof Request) {
        
        decode(((Request) message).getData());
			
			DecodeHandler decode
				
				((Decodeable) message).decode();
					
					DecodeableRpcInvocation decode
						
						if (!hasDecoded && channel != null && inputStream != null) {
							
							decode(channel, inputStream);
								
								ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), serializationType)
						                .deserialize(channel.getUrl(), input);
						        this.put(SERIALIZATION_ID_KEY, serializationType);

						        String dubboVersion = in.readUTF();
						        request.setVersion(dubboVersion);
						        setAttachment(DUBBO_VERSION_KEY, dubboVersion);

						        String path = in.readUTF();
						        setAttachment(PATH_KEY, path);
						        String version = in.readUTF();
						        setAttachment(VERSION_KEY, version);
						        setMethodName(in.readUTF());

						        String desc = in.readUTF();
						        setParameterTypesDesc(desc);
						        
						        Object[] args = DubboCodec.EMPTY_OBJECT_ARRAY;
            					Class<?>[] pts = DubboCodec.EMPTY_CLASS_ARRAY;
						        
						        if (desc.length() > 0) { //  Ljava/lang/String;
						        	ServiceRepository repository = ApplicationModel.getServiceRepository();
					                ServiceDescriptor serviceDescriptor = repository.lookupService(path);
					                if (serviceDescriptor != null) {
					                    MethodDescriptor methodDescriptor = serviceDescriptor.getMethod(getMethodName(), desc);
					                    if (methodDescriptor != null) {
					                        pts = methodDescriptor.getParameterClasses();
					                        this.setReturnTypes(methodDescriptor.getReturnTypes());
					                    }
					                }
					                args = new Object[pts.length];
					                for (int i = 0; i < args.length; i++) {
					                    try {
					                        args[i] = in.readObject(pts[i]);
					            
					            setParameterTypes(pts);
					            setArguments(args);
					            
					            setObjectAttachments(in.readAttachments(););
					            
					            setTargetServiceUniqueName(targetServiceName);
					            
					            if (in instanceof Cleanable) {
					                ((Cleanable) in).cleanup();
					                	mH2i.reset();

							hasDecoded = true;

	handler.received(channel, message);
	// 另起一行


HeaderExchangeHandler received
	
	final ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);
	        
	        if (message instanceof Request) {
	            
	            Request request = (Request) message;
	            if (request.isEvent()) {
	           		// ....
	            } else {
	                if (request.isTwoWay()) {
	                    
	                    handleRequest(exchangeChannel, request);
	                    	
	                    	Response res = new Response(req.getId(), req.getVersion());
	                    	if (req.isBroken()) {
	                    		// ....
	                    		return;
	                    	}
	                    	
	                    	Object msg = req.getData();
	                    	CompletionStage<Object> future = handler.reply(channel, msg);

	                    		requestHandler reply(ExchangeChannel channel, Object message)

	                    			Invocation inv = (Invocation) message;
            						Invoker<?> invoker = getInvoker(channel, inv);
	            						String serviceKey = serviceKey(
								                channel.getLocalAddress().getPort(),
								                (String) inv.getObjectAttachments().get(PATH_KEY),
								                (String) inv.getObjectAttachments().get(VERSION_KEY),
								                (String) inv.getObjectAttachments().get(GROUP_KEY)
								        );
								        DubboExporter<?> exporter = (DubboExporter<?>) exporterMap.get(serviceKey);
								        return exporter.getInvoker();
								        	AbstractExporter getInvoker
								        		return invoker;

				            		RpcContext.getContext().setRemoteAddress(channel.getRemoteAddress());
						            
						            Result result = invoker.invoke(inv);
						            	// 另起一行 见 FilterNode invoke

						            return result.thenApply(Function.identity());

				            future.whenComplete((appResult, t) -> {
				                try {
				                    if (t == null) {
				                        res.setStatus(Response.OK);
				                        res.setResult(appResult);
				                    } else {
				                        res.setStatus(Response.SERVICE_ERROR);
				                        res.setErrorMessage(StringUtils.toString(t));
				                    }

				                    channel.send(res);
				                    	HeaderExchangeChannel send
				                    		NettyChannel send
												channel.writeAndFlush(message);

				                } catch (RemotingException e) {
				                    logger.warn("Send result to consumer failed, channel is " + channel + ", msg is " + e);
				                }
				            });
// ====================================================================

// todo

FilterNode invoke
	ContextFilter invoke

FilterNode invoke
	EchoFilter	invoke

FilterNode invoke
	ClassLoaderFilter	invoke

FilterNode invoke
	GenericFilter	invoke
	.... 
	TraceFilter
	TimeoutFilter
	MoniterFilter
	ExceptionFilter

InvokerWrapper invoke // this 为 InvokerDelegate

	DelegateProviderMetaDataInvoker invoke	

		AbstractProxyInvoker invoke // this 为javassist生成的 注意 proxy 为DemoServiceImpl

			JavassistProxyFactory$1 doInvoke

ExceptionFilter onResponse
TimeoutFilter onResponse
MoniterFilter onResponse
TraceFilter invoke
GenericFilter onResponse
ClassLoaderFilter invoke
ContextFilter onResponse


// todo 需要debug跟踪的 ====================================================================
TimeoutCheckTask

// todo need pr ====================================================================
ConsumerContextClusterInterceptor 
 RpcContext context = RpcContext.getContext();
        context.setInvocation(invocation).setLocalAddress(NetUtils.getLocalHost(), 0);
        可以删除这部分，因为和ConsumerContextFilter重复了


 AbstractInvoker       invocation.setInvoker(this);  和  ConsumerContextFilter 重复



// todo methods = {@Method(name = "greeting", timeout = 9999999, retries = 1)}) 专门针对不同方法的超时时间是怎么处理的


