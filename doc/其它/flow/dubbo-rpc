ReferenceBean#getObject返回的ref为
ref = {proxy0@4260} 
 handler = {InvokerInvocationHandler@4280} 
  invoker = {ServiceDiscoveryMigrationInvoker@4263} 
  consumerModel = {ConsumerModel@4281} 
  url = {URL@4282} "dubbo://30.25.58.158/samples.servicediscovery.demo.DemoService?application=demo-consumer&check=false&dubbo=2.0.2&init=false&interface=samples.servicediscovery.demo.DemoService&mapping-type=metadata&mapping.type=metadata&metadata-type=remote&methods=sayHello&pid=64096&provided-by=demo-provider&register.ip=30.25.58.158&side=consumer&sticky=false&timestamp=1620702737234"
  protocolServiceKey = "samples.servicediscovery.demo.DemoService:dubbo"
// ====================================================================


String hello = demoService.sayHello("world");

InvokerInvocationHandler invoke

	method.getDeclaringClass() == Object.class
		return method.invoke(invoker, args);

	toString、hashCode、$destroy、equals

	RpcInvocation rpcInvocation = new RpcInvocation(method, invoker.getInterface().getName(), protocolServiceKey, args);
	rpcInvocation.setTargetServiceUniqueName(invoker.getUrl().getServiceKey());
		invoker.getUrl
			MigrationInvoker getUrl
				if (invoker != null) {
            				invoker.getUrl();
            					MockClusterInvoker getUrl
            						directory.getConsumerUrl()
            							RegistryDirectory.getConsumerUrl
            								overrideDirectoryUrl;

	RpcContext.setRpcContext(invoker.getUrl());

		RpcContext.getContext().setConsumerUrl(url);
       
	invoker.invoke(rpcInvocation).recreate();

		if (!checkInvokerAvailable(serviceDiscoveryInvoker)) {

			invoker.invoke(invocation);

				MockClusterInvoker invoke

				.... // 同下

		if (!checkInvokerAvailable(invoker)) 

			ServiceDiscoveryMigrationInvoker invoke

				MockClusterInvoker invoke

					InterceptorInvokerNode invoke

						ConsumerContextClusterInterceptor before
							context.setInvocation(invocation).setLocalAddress(NetUtils.getLocalHost(), 0);
							((RpcInvocation) invocation).setInvoker(invoker);
							RpcContext.removeServerContext();

						ConsumerContextClusterInterceptor  intercept 

							ClusterInterceptor intercept // 接口的默认方法
							
								clusterInvoker.invoke(invocation);
								
									AbstractClusterInvoker invoke  // this为 FailoverClusterInvoker

										checkWhetherDestroyed();

										invocation.addObjectAttachments(RpcContext.getContext().getObjectAttachments());

										AbstractClusterInvoker list

											directory.list(invocation);

												AbstractDirectory list

													if (destroyed) 
														throw

													doList(invocation);

														// registry://
														RegistryDirectory doList

															if (forbidden) {
															if (multiGroup) {

															return invokers = routerChain.route(getConsumerUrl(), invocation);

																RouterChain route
														
														// sd://
														DynamicDirectory doList
															RouterChain route(mock、tag、service、app)
										initLoadBalance
											getExtension(invokers.get(0).getUrl().getMethodParameter("loadbalance"))

										RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);

										doInvoke(invocation, invokers, loadbalance);

											FailoverClusterInvoker doInvoke

											 	checkInvokers(copyInvokers, invocation);

											 	for (int i = 0; i < len; i++)

											 		Invoker<T> invoker = select(loadbalance, invocation, copyInvokers, invoked);

											 		 	AbstractClusterInvoker select

											 		 		doSelect(loadbalance, invocation, invokers, selected);

											 		RpcContext.getContext().setInvokers((List) invoked);

											 		Result result = invoker.invoke(invocation);

											 			RegistryDirectory InvokerDelegate invoke

											 				InvokerWrapper invoke
											 					FilterNode invoke 
											 						filter.invoke(next, invocation); // ConsumerContextFilter
											 							ConsumerContextFilter invoke
																			invoker.invoke(invocation);
																				FilterNode invoke 
																					filter.invoke(next, invocation);
																						FutureFilter invoke
																							MonitorFilter invoke
																								层次太深，另起开头

ListenerInvokerWrapper invoke

	AsyncToSyncInvoker invoke

		Result asyncResult = invoker.invoke(invocation);

			AbstractInvoker invoke // this为DubboInvoker

				invocation.setInvoker(this);
				invocation.addObjectAttachmentsIfAbsent(attachment);
				invocation.addObjectAttachments(contextAttachments);
				invocation.setInvokeMode(RpcUtils.getInvokeMode(url, invocation));
				RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);
				invocation.put(SERIALIZATION_ID_KEY, serializationId);

				(AsyncRpcResult) doInvoke(invocation);

					DubboInvoker doInvoke

						inv.setAttachment(PATH_KEY, getUrl().getPath());
						inv.setAttachment(VERSION_KEY, version);
						invocation.put(TIMEOUT_KEY, timeout);

						ExecutorService executor = getCallbackExecutor(getUrl(), inv);

							AbstractInvoker getCallbackExecutor

								InvokeMode.SYNC == RpcUtils.getInvokeMode(getUrl(), inv)

									ThreadlessExecutor(ExecutorService sharedExecutor) 

										this.sharedExecutor = sharedExecutor;

						CompletableFuture<AppResponse> appResponseFuture =
	                        currentClient.request(inv, timeout, executor).thenApply(obj -> (AppResponse) obj);

								ReferenceCountExchangeClient request

									client.request(request, timeout, executor);

										HeaderExchangeClient request

											channel.request(request, timeout, executor);

												HeaderExchangeChannel request

													Request req = new Request();
													req.setTwoWay(true);
													req.setData(request);// request为inv

													DefaultFuture.newFuture(channel, req, timeout, executor);
														
														new DefaultFuture(channel, request, timeout);

														future.setExecutor(executor);
														
														ThreadlessExecutor setWaitingFuture
															this.waitingFuture = waitingFuture;
														
														timeoutCheck
														
														return future;

													channel.send(req)

														AbstractPeer send //  this 为 NettyChannel

															send(message, url.getParameter(Constants.SENT_KEY, false));

																AbstractClient send

																	if (needReconnect && !isConnected())
															            connect();

															        Channel channel = getChannel();
															        	
															        	NettyClient getChannel
															        		
															        		NettyChannel.getOrAddChannel(channel, getUrl(), this);
															       
															        channel.send(message, sent);
															        	
															        	NettyChannel send 
															        	
															        	AbstractChannel send
																		
																		ChannelFuture future = channel.writeAndFlush(message);
																		
																		if (sent) 
																			success = future.await(timeout);
													return future;
							
							FutureContext.getContext().setCompatibleFuture(appResponseFuture);
			                
			                AsyncRpcResult result = new AsyncRpcResult(appResponseFuture, inv);
			                
			                result.setExecutor(executor);
			                	// 这里是ThreadlessExecutor
			                
			                return result;
			    
			    RpcContext.getContext().setFuture(new FutureAdapter(asyncResult.getResponseFuture()));
	        	return asyncResult;            

	    if (InvokeMode.SYNC == ((RpcInvocation) invocation).getInvokeMode()) 

	     	asyncResult.get(Integer.MAX_VALUE, TimeUnit.MILLISECONDS);

	     		if (executor != null && executor instanceof ThreadlessExecutor) {
            		ThreadlessExecutor threadlessExecutor = (ThreadlessExecutor) executor;
            		threadlessExecutor.waitAndDrain();

            			Runnable runnable = queue.take();

            				runnable.run();

            					TimeoutCheckTask#run () -> notifyTimeout(future)

            						Response timeoutResponse = new Response(future.getId());

            							 DefaultFuture.received(future.getChannel(), timeoutResponse, true);
            							 
            							 // todo 继续
            			// todo 继续
        
        return asyncResult;

// todo 继续

// ====================================================================
下面是客户端同步处理剩余逻辑

.....
AsyncToSyncInvoker  asyncResult.get(Integer.MAX_VALUE, TimeUnit.MILLISECONDS);

AsyncRpcResult get

threadlessExecutor.waitAndDrain();

ChannelEventRunnable run

DecodeHandler received
	decode

DecodeableRpcResult	decode
	AppResponse setValue
	\
HeaderExchangeHandler received
 
	HeaderExchangeHandler handleResponse
		DefaultFuture.received
			DefaultFuture doReceived

AsyncToSyncInvoker get

FailoverClusterInvoker
	  Result result = invoker.invoke(invocation);


下面是客户端接收响应包
// ====================================================================


InternalDecoder decode

DubboCountCodec decode

ExchangdeCodec decode

DubboCodec decodeBody

NettyClientHandler channelRead

AbstractPeer received

MultiMessageHandler received

HeartbeatHandler received

AllChannelHandler received
	DefaultFuture getFuture
	executor = ThreadlessExecutor
		RunnableWrapper

asyncResult.get(Integer.MAX_VALUE, TimeUnit.MILLISECONDS);

下面是异步写server并从server角度处理和回传响应
// ====================================================================
	NettyClientHandler write

	InternalEncoder encode

	DubboCountCodec encode

	ExchangeCodec encode

	DubboCodec encodeRequestData 


	// server
	InternalDecoder decode

	DubboCountCodec decode

	ExchangeCodec decode

	DubboCodec decodeBody

	NettyServerHandler channelRead

	AbstractPeer received

	MultiMessageHandler received

	HeartbeatHandler received

	AllChannelHandler received

	DecodeHandler received
		DecodeHandler decode

		DecodeableRpcInvocation decode

	HeaderExchangeHandler received
 
	requestHandler received

	FilterNode invoke
		ContextFilter invoke

	FilterNode invoke
		EchoFilter	invoke

	FilterNode invoke
		ClassLoaderFilter	invoke

	FilterNode invoke
		GenericFilter	invoke
		.... 
		TraceFilter
		TimeoutFilter
		MoniterFilter
		ExceptionFilter
	InvokerWrapper invoke - this 为 InvokerDelegate

	DelegateProviderMetaDataInvoker invoke	

	AbstractProxyInvoker invoke - this 为javassist生成的 注意 proxy 为DemoServiceImpl

	JavassistProxyFactory$1 doInvoke

	ExceptionFilter onResponse
	TimeoutFilter onResponse
	MoniterFilter onResponse

	TraceFilter invoke
	GenericFilter onResponse
	ClassLoaderFilter invoke
	ContextFilter onResponse

	requestHandler reply


	HeaderExchangeHandler handleRequest

	HeaderExchangeChannel send

	NettyChannel send

	channel.writeAndFlush(message);

// todo 需要debug跟踪的 ====================================================================
TimeoutCheckTask

// todo need pr ====================================================================
ConsumerContextClusterInterceptor 
 RpcContext context = RpcContext.getContext();
        context.setInvocation(invocation).setLocalAddress(NetUtils.getLocalHost(), 0);
        可以删除这部分，因为和ConsumerContextFilter重复了


 AbstractInvoker       invocation.setInvoker(this);  和  ConsumerContextFilter 重复






