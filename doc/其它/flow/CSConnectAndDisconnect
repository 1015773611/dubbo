
// ====================================================================
	server 接收到 client 的 连接请求
// ====================================================================
NettyServerHandler
	 public void channelActive(ChannelHandlerContext ctx) throws Exception {
        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);
        if (channel != null) {
            channels.put(NetUtils.toAddressString((InetSocketAddress) ctx.channel().remoteAddress()), channel);
        }
        handler.connected(channel);
        	AbstractServer connected(Channel ch)
        		if (this.isClosing() || this.isClosed()) {
		            logger.warn("Close new channel " + ch + ", cause: server is closing or has been closed. For example, receive a new connect request while in shutdown process.");
		            ch.close();
		            return;
		        }

		        if (accepts > 0 && getChannels().size() > accepts) {
		            logger.error("Close channel " + ch + ", cause: The server " + ch.getLocalAddress() + " connections greater than max config " + accepts);
		            ch.close();
		            return;
		        }
		        super.connected(ch);
		        	AbstractPeer connected(Channel ch)
		        		if (closed) {
			            return;
			        }
			        handler.connected(ch);

			        	AbstractChannelHandlerDelegate connected(Channel channel) // this 为 MultiMessageHandler
			        		 handler.connected(channel); 

			        		 HeartbeatHandler connected(Channel channel)
			        		 	setReadTimestamp(channel);
						        setWriteTimestamp(channel);
						        handler.connected(channel);

						        	AllChannelHandler connected(Channel channel) 

								        ExecutorService executor = getExecutorService();
								        	return getSharedExecutorService();
								        		// ....
								        try {
								            executor.execute(new ChannelEventRunnable(channel, handler, ChannelState.CONNECTED));
								            	// 另换行
								        } catch (Throwable t) {
								            throw new ExecutionException("connect event", channel, getClass() + " error when process connected event .", t);
								        }
								    }

        if (logger.isInfoEnabled()) {
            logger.info("The connection of " + channel.getRemoteAddress() + " -> " + channel.getLocalAddress() + " is established.");
        }
    }

// ====================================================================


ChannelEventRunnable run() {
else {
    switch (state) {
    case CONNECTED:
        try {
            handler.connected(channel);
            	
            	AbstractChannelHandlerDelegate connected(Channel channel) // this为decodehandler
			        
			        handler.connected(channel);
			        	
			        	HeaderExchangeHandler connected(Channel channel)
			        		
			        		ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);
			        			if (ch == null) {
						            return null;
						        }
						        HeaderExchangeChannel ret = (HeaderExchangeChannel) ch.getAttribute(CHANNEL_KEY);
						        if (ret == null) {
						            ret = new HeaderExchangeChannel(ch);
						            	this.channel = channel;
						            if (ch.isConnected()) {
						                ch.setAttribute(CHANNEL_KEY, ret);
						            }
						        }
						        return ret;
        					
        					handler.connected(exchangeChannel);
        						
        						DubboProtocol requestHandler connected(Channel channel)
									
									invoke(channel, ON_CONNECT_KEY);

										Invocation invocation = createInvocation(channel, channel.getUrl(), methodKey);
											// 为null
							            if (invocation != null) {
							                try {
							                    received(channel, invocation);
							                } catch (Throwable t) {
							                    logger.warn("Failed to invoke event method " + invocation.getMethodName() + "(), cause: " + t.getMessage(), t);
							                }
							            }
			    }
        } catch (Exception e) {
            logger.warn("ChannelEventRunnable handle " + state + " operation error, channel is " + channel, e);
        }
        break;

// ====================================================================
	
	server 接收到 client 的断联

// ====================================================================
NettyServerHandler 

public void channelInactive(ChannelHandlerContext ctx) throws Exception {
    NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);
    try {
        channels.remove(NetUtils.toAddressString((InetSocketAddress) ctx.channel().remoteAddress()));
        handler.disconnected(channel);
        	AbstractServer disconnected
	        	Collection<Channel> channels = getChannels();
		        if (channels.isEmpty()) {
		            logger.warn("All clients has disconnected from " + ch.getLocalAddress() + ". You can graceful shutdown now.");
		        }
		        super.disconnected(ch);
		        	AbstractPeer disconnected
		        		handler.disconnected(ch);、
		        			AbstractChannelHandlerDelegate disconnected // this 为 Multi
		        				HeartbeatHandler disconnected
		        					clearReadTimestamp(channel);
								        clearWriteTimestamp(channel);
								        handler.disconnected(channel);
								        	AllChannelHandler disconnected(Channel channel)
								        		 ExecutorService executor = getExecutorService();
            										executor.execute(new ChannelEventRunnable(channel, handler, ChannelState.DISCONNECTED));
            											ChannelEventRunnable
            												case DISCONNECTED:
            													handler.disconnected(channel);
            														AbstractChannelHandlerDelegate disconnected
            															HeaderExchangeHandler disconnected
            															// 另换行
    } finally {
        NettyChannel.removeChannel(ctx.channel());
        	if (ch != null) {
	            NettyChannel nettyChannel = CHANNEL_MAP.remove(ch);
	            if (nettyChannel != null) {
	                nettyChannel.markActive(false);
	            }
	        }
    }

    if (logger.isInfoEnabled()) {
        logger.info("The connection of " + channel.getRemoteAddress() + " -> " + channel.getLocalAddress() + " is disconnected.");
    }
}

HeaderExchangeHandler disconnected
	ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);
    try {
        handler.disconnected(exchangeChannel);
        	requestHandler disconnected
        		invoke(channel, ON_DISCONNECT_KEY);
    } finally {
        DefaultFuture.closeChannel(channel);
        	for (Map.Entry<Long, Channel> entry : CHANNELS.entrySet()) {
	            if (channel.equals(entry.getValue())) {
	                DefaultFuture future = getFuture(entry.getKey());
	                if (future != null && !future.isDone()) {
	                    ExecutorService futureExecutor = future.getExecutor();
	                    if (futureExecutor != null && !futureExecutor.isTerminated()) {
	                        futureExecutor.shutdownNow();
	                    }

	                    Response disconnectResponse = new Response(future.getId());
	                    disconnectResponse.setStatus(Response.CHANNEL_INACTIVE);
	                    disconnectResponse.setErrorMessage("Channel " +
	                            channel +
	                            " is inactive. Directly return the unFinished request : " +
	                            future.getRequest());
	                    DefaultFuture.received(channel, disconnectResponse);
	                }
	            }
	        }
        HeaderExchangeChannel.removeChannel(channel);
        	if (ch != null) {
	            ch.removeAttribute(CHANNEL_KEY);
	        }
    }


// ====================================================================
   client 接受 到服务端的连接
// ====================================================================

	public void channelActive(ChannelHandlerContext ctx) throws Exception {
        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);
        handler.connected(channel);
        	AbstractPeer connected
        		if (closed) {
		            return;
		        }
		        handler.connected(ch);
		        	// 后续流程和server一模一样，最终也是到requestHandler ，因为在DubboProtocol在connect的时候也指定了requestHandler（不光是在export指定的）
        if (logger.isInfoEnabled()) {
            logger.info("The connection of " + channel.getLocalAddress() + " -> " + channel.getRemoteAddress() + " is established.");
        }
    }












    














    














    














    














    














    